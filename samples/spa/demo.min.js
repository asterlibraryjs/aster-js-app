class AssertionError extends Error {
}
var asserts;
(function (asserts) {
    function defined(value, message) {
        if (typeof value === "undefined") {
            throw new AssertionError(message !== null && message !== void 0 ? message : "Value expected to be defined");
        }
    }
    asserts.defined = defined;
    function notDefined(value, message) {
        if (typeof value !== "undefined") {
            throw new AssertionError(message !== null && message !== void 0 ? message : "Value expected to be undefined");
        }
    }
    asserts.notDefined = notDefined;
    function object(value, message) {
        if (typeof value === "object" && value !== null) {
            throw new AssertionError(message !== null && message !== void 0 ? message : "Value expected to be an object");
        }
    }
    asserts.object = object;
    function ensure(value, message) {
        if (typeof value === "undefined" || value === null) {
            throw new AssertionError(message !== null && message !== void 0 ? message : "Value expected to be defined and not null");
        }
    }
    asserts.ensure = ensure;
    function returns(value, message) {
        ensure(value, message);
        return value;
    }
    asserts.returns = returns;
    function ofType(value, type, message) {
        if (typeof value !== type) {
            throw new AssertionError(message !== null && message !== void 0 ? message : `Expected typeof "${type}" but having a typeof "${typeof value}"`);
        }
    }
    asserts.ofType = ofType;
    function instanceOf(value, type, message) {
        if (!(value instanceof type)) {
            throw new AssertionError(message !== null && message !== void 0 ? message : `Expected to be an instance of "${type.name}"`);
        }
    }
    asserts.instanceOf = instanceOf;
    function create(predicate) {
        return (value, message) => {
            if (predicate(value))
                throw new AssertionError(message !== null && message !== void 0 ? message : "Assertion failed");
        };
    }
    asserts.create = create;
})(asserts || (asserts = {}));if (!Symbol.dispose)
    Object.assign(Symbol, { dispose: Symbol("dispose") });
function IDisposable(ctor) {
    class CustomDisposable extends ctor {
    }
    for (const key of Reflect.ownKeys(DisposableHost.prototype)) {
        const desc = Object.assign({}, Reflect.getOwnPropertyDescriptor(DisposableHost.prototype, key));
        Reflect.defineProperty(CustomDisposable.prototype, key, desc);
    }
    return CustomDisposable;
}
(function (IDisposable) {
    /** @deprecated use Symbol.dispose instead */
    IDisposable.dispose = Symbol.dispose;
    /**
     * Create a new IDisposable from a callback
     * @param callback Callback to call when dispose is invoked
     * @returns Returns a new IDiposable instance
     */
    function create(callback) {
        return {
            [Symbol.dispose]: () => {
                callback();
            }
        };
    }
    IDisposable.create = create;
    /**
     * Dispose all provide instances, support any iterable instance.
     * @param instances Instances to dispose
     * @returns Returns all errors encountered during disposing each instances.
     */
    function safeDisposeAll(instances) {
        if (typeof instances === "object" && instances !== null && typeof instances[Symbol.iterator] === "function") {
            return [...instances].map(safeDispose);
        }
        return [];
    }
    IDisposable.safeDisposeAll = safeDisposeAll;
    /**
     * Dispose the provided instance and catch exceptions that may occur
     * @param instance Instance to dispose
     * @returns Returns the catched disposing error or undefined
     */
    function safeDispose(instance) {
        if (typeof instance === "object" && instance !== null && typeof instance[IDisposable.dispose] === "function") {
            try {
                instance[IDisposable.dispose]();
            }
            catch (ex) {
                return ex;
            }
        }
    }
    IDisposable.safeDispose = safeDispose;
    /**
     * Check if an instance is disposed, throw an error if it is
     * @param instance Instance to check
     */
    function checkDisposed(instance) {
        if (instance.disposed)
            throw new DisposedError("Try to access to a disposed instance");
    }
    IDisposable.checkDisposed = checkDisposed;
})(IDisposable || (IDisposable = {}));
/**
 * Error triggered when trying to use a diposed instance
 */
class DisposedError extends Error {
}
/** Represents a class that contains dependencies to dispose */
class DisposableHost {
    get disposed() { return Boolean(this._disposed); }
    /**
     * Register all provided instances to dispose them when current instance will be disposed
     * @param disposables Instance to attach
     */
    registerForDispose(...disposables) {
        for (const disposable of disposables) {
            if (!this._disposables) {
                this._disposables = new Set([disposable]);
            }
            else {
                this._disposables.add(disposable);
            }
        }
    }
    checkIfDisposed() {
        IDisposable.checkDisposed(this);
    }
    [IDisposable.dispose]() {
        if (!this._disposed) {
            this._disposed = true;
            IDisposable.safeDisposeAll(this._disposables);
            delete this._disposables;
            this.dispose && this.dispose();
        }
    }
}const IsLazyProxy = Symbol();
class Lazy {
    get disposed() { return this._state === 4 /* LazyState.disposed */; }
    constructor(_factory, ctor) {
        this._factory = _factory;
        this._prototype = ctor === null || ctor === void 0 ? void 0 : ctor.prototype;
    }
    build() {
        IDisposable.checkDisposed(this);
        if (this._state === 2 /* LazyState.value */)
            return false;
        try {
            const result = this._factory();
            // Avoid keeping references through the factory callback
            // Avoid also any dirty hacked state to throw errors with strong reference to value
            this._factory = () => result;
            this._value = result;
            this._state = 2 /* LazyState.value */;
            if (typeof this._value === "object") {
                this._prototype = Reflect.getPrototypeOf(this._value);
            }
        }
        catch (err) {
            this._value = err;
            this._state = 1 /* LazyState.proxy */;
        }
        return true;
    }
    has() {
        return this._state === 2 /* LazyState.value */;
    }
    get() {
        IDisposable.checkDisposed(this); // LazyState.disposed
        if (this._state === 3 /* LazyState.faulted */)
            throw this._value;
        if (typeof this._state === "undefined") {
            this._value = new Proxy(Object.create(null), this.createProxyHandler());
            this._state = 1 /* LazyState.proxy */;
        }
        // LazyState.proxy &  LazyState.value
        return this._value;
    }
    [IDisposable.dispose]() {
        if (this._state === 2 /* LazyState.value */) {
            IDisposable.safeDispose(this._value);
        }
        this._state = 4 /* LazyState.disposed */;
        // Avoid keeping references through the factory callback
        this._factory = () => { throw new DisposedError(); };
    }
    getInstance() {
        this.build(); // CheckDisposed done
        if (this._state === 3 /* LazyState.faulted */)
            throw this._value;
        return this._value;
    }
    createProxyHandler() {
        return {
            get: (_, prop) => {
                if (prop === IsLazyProxy)
                    return true;
                return this.getInstance()[prop];
            },
            set: (_, p, value) => {
                this.getInstance()[p] = value;
                return true;
            },
            deleteProperty: (_, p) => {
                delete this.getInstance()[p];
                return true;
            },
            getPrototypeOf: (_) => {
                var _a;
                return (_a = this._prototype) !== null && _a !== void 0 ? _a : Object;
            }
        };
    }
    static get(factory, ctor) {
        const lazy = new Lazy(factory, ctor);
        return lazy.get();
    }
}function createReadOnlyTag(description, has, get) {
    const readOnlyTag = Object.assign(target => get(target), {
        get, has,
        toString: () => description
    });
    return Object.freeze(readOnlyTag);
}
/** Create a new Tag */
function Tag(description, defaultValue) {
    const store = new WeakMap();
    const has = (target) => store.has(target);
    const get = (target) => has(target) ? store.get(target) : defaultValue;
    const set = (target, value) => void store.set(target, value);
    const readOnlyTag = createReadOnlyTag(description, has, get);
    return Object.assign((...args) => args.length == 1 ? get(args[0]) : set(args[0], args[1]), readOnlyTag, {
        readOnly: () => readOnlyTag,
        set,
        delete: target => store.delete(target)
    });
}
(function (Tag) {
    function lazy(description, factory, state) {
        const store = new WeakMap();
        const has = (target) => store.has(target);
        const get = (target) => {
            if (!has(target)) {
                store.set(target, factory(target, state));
            }
            return store.get(target);
        };
        return createReadOnlyTag(description, has, get);
    }
    Tag.lazy = lazy;
})(Tag || (Tag = {}));var Tags;
(function (Tags) {
    /**
     * hashId allow to attribute a id to an instance to simplify the creation of hash codes.
     * Using hashId, you can create a hashCode by simply string concat two of these id with a separator.
     *
     * This is very usefull in case of compound keys where the key targets two objects
     * and have to be the key of a Map or a Set.
     *
     * @example
     * // This hash will be unique and can be reproduced
     * `${Tags.hashId.get(obj1)}-${Tags.hashId.get(obj2)}`;
     */
    Tags.hashId = Tag.lazy("hashId", (_, state) => ++state.lastId, { lastId: 0 });
})(Tags || (Tags = {}));class HashMap {
    constructor(hashFactory = k => k, values) {
        this._hashFactory = hashFactory;
        this._store = new Map(this.mapEntries(values));
    }
    get size() { return this._store.size; }
    get [Symbol.toStringTag]() { return "[Object HashMap]"; }
    has(key) {
        const hash = this._hashFactory(key);
        return this._store.has(hash);
    }
    get(key) {
        const entry = this.getEntry(key);
        if (entry)
            return entry[1];
    }
    getOrElse(key, fallback) {
        const entry = this.getEntry(key);
        return entry ? entry[1] : fallback;
    }
    getEntry(key) {
        const hash = this._hashFactory(key);
        return this._store.get(hash);
    }
    getOrSet(key, factory) {
        const hash = this._hashFactory(key);
        const entry = this._store.get(hash);
        if (!entry) {
            const value = factory(key, this);
            if (value instanceof Promise) {
                return this.addAsync(hash, key, value);
            }
            this._store.set(hash, [key, value]);
            return value;
        }
        return entry[1];
    }
    async addAsync(hash, key, valuePromise) {
        const value = await valuePromise;
        this._store.set(hash, [key, value]);
        return value;
    }
    set(key, value) {
        const hash = this._hashFactory(key);
        this._store.set(hash, [key, value]);
        return this;
    }
    delete(key) {
        const hash = this._hashFactory(key);
        return this._store.delete(hash);
    }
    clear() {
        this._store.clear();
    }
    forEach(callbackfn, thisArg) {
        for (const [key, value] of this) {
            callbackfn.call(thisArg, value, key, this);
        }
    }
    *keys() {
        for (const [k, _] of this) {
            yield k;
        }
    }
    *values() {
        for (const [_, v] of this) {
            yield v;
        }
    }
    *entries() {
        for (const entry of this._store.values()) {
            yield [...entry];
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    *mapEntries(entries) {
        if (entries) {
            for (const [k, v] of entries) {
                yield [this._hashFactory(k), [k, v]];
            }
        }
    }
}class HashSet {
    constructor(hashFactory = String, values) {
        this._hashFactory = hashFactory;
        this._store = new Map(this.mapEntries(values));
    }
    get size() { return this._store.size; }
    get [Symbol.toStringTag]() { return "[Object HashSet]"; }
    has(key) {
        const hash = this._hashFactory(key);
        return this._store.has(hash);
    }
    add(key) {
        const hash = this._hashFactory(key);
        this._store.set(hash, key);
        return this;
    }
    delete(key) {
        const hash = this._hashFactory(key);
        return this._store.delete(hash);
    }
    clear() {
        this._store.clear();
    }
    forEach(callbackfn, thisArg) {
        for (const key of this) {
            callbackfn.call(thisArg, key, key, this);
        }
    }
    keys() {
        return this._store.values();
    }
    *entries() {
        for (const item of this._store.values()) {
            yield [item, item];
        }
    }
    values() {
        return this.keys();
    }
    [Symbol.iterator]() {
        return this.keys();
    }
    *mapEntries(entries) {
        if (entries) {
            for (const k of entries) {
                yield [this._hashFactory(k), k];
            }
        }
    }
}class Lookup {
    constructor(hashFactory) {
        this._store = hashFactory ? new HashMap(hashFactory) : new Map();
        this._itemSize = 0;
    }
    get size() { return this._store.size; }
    get itemSize() { return this._itemSize; }
    get [Symbol.toStringTag]() { return "[Object Lookup]"; }
    has(key) {
        return this._store.has(key);
    }
    hasValue(key, value) {
        var _a;
        const entries = this._store.get(key);
        return (_a = entries === null || entries === void 0 ? void 0 : entries.includes(value)) !== null && _a !== void 0 ? _a : false;
    }
    include(value) {
        for (const val of this.values()) {
            if (val === value)
                return true;
        }
        return false;
    }
    first(key) {
        const entries = this._store.get(key);
        if (entries)
            return entries[0];
    }
    last(key) {
        const entries = this._store.get(key);
        if (entries)
            return entries[entries.length - 1];
    }
    *get(key) {
        const entries = this._store.get(key);
        if (entries)
            yield* entries;
    }
    add(key, ...values) {
        const entries = this._store.get(key);
        if (entries) {
            entries.push(...values);
        }
        else {
            this._store.set(key, values);
        }
        this._itemSize++;
        return this;
    }
    delete(key) {
        const entries = this._store.get(key);
        if (entries) {
            this._itemSize -= entries.length;
            return this._store.delete(key);
        }
        return false;
    }
    deleteValue(key, value) {
        const entries = this._store.get(key);
        if (entries) {
            const idx = entries.indexOf(value);
            if (idx !== -1) {
                if (entries.length === 1) {
                    this._store.delete(key);
                }
                else {
                    entries.splice(idx, 1);
                }
                this._itemSize--;
                return true;
            }
        }
        return false;
    }
    clear() {
        this._itemSize = 0;
        this._store.clear();
    }
    forEach(callbackfn, thisArg) {
        for (const [key, values] of this._store) {
            for (const value of values) {
                callbackfn.call(thisArg, value, key, this);
            }
        }
    }
    *keys() {
        yield* this._store.keys();
    }
    *values() {
        for (const values of this._store.values()) {
            yield* values;
        }
    }
    *[Symbol.iterator]() {
        yield* this._store;
    }
    static create(values, hashFactory) {
        const lookup = new Lookup(hashFactory);
        for (const item of values) {
            lookup.add(...item);
        }
        return lookup;
    }
}class ServiceRegistry {
    constructor(_resolver, _tag) {
        this._resolver = _resolver;
        this._tag = _tag;
        this._serviceIds = new Map();
        this._dependencies = new Map();
    }
    *dependencies(ctor) {
        const deps = this._dependencies.get(ctor);
        if (deps)
            yield* deps.sort((l, r) => l.index - r.index);
    }
    get(tag) {
        const entry = this._serviceIds.get(tag);
        return entry ? entry[0] : null;
    }
    resolve(ctor) {
        const entry = this._serviceIds.get(ctor);
        if (entry)
            return entry[0];
        return this._resolver(ctor);
    }
    add(serviceId, options) {
        const tagId = ServiceIdentityTag(serviceId);
        if (!tagId) {
            throw new Error(`Invalid service id: ${serviceId}`);
        }
        if (this._serviceIds.has(tagId)) {
            throw new Error(`Service "${options.name}" already exists.`);
        }
        this._serviceIds.set(tagId, [serviceId, options]);
    }
    addDependency(serviceCtor, serviceId, index, type) {
        const dependencies = this._dependencies.get(serviceCtor);
        if (dependencies) {
            dependencies.push({ serviceId, index, type });
            dependencies.sort((a, b) => a.index - b.index);
        }
        else {
            this._dependencies.set(serviceCtor, [{ serviceId, index, type }]);
        }
    }
}const serviceIdentityTag = Tag("IoC/ServiceId");
const ServiceIdentityTag = serviceIdentityTag.readOnly();
function ServiceIdentifier(nameOrOptions) {
    const options = typeof nameOrOptions === "string" ? { name: nameOrOptions } : nameOrOptions;
    const hashValue = options.unique ? options.name : Symbol(options.name);
    return create(hashValue, options);
}
(function (ServiceIdentifier) {
    ServiceIdentifier.registry = new ServiceRegistry(of, ServiceIdentityTag);
    /**
     * Returns a new service identifier for a specific type
     *
     * This method will strongly bind implementation to a specific type
     */
    function of(ctor) {
        return create(ctor, { name: ctor.name });
    }
    ServiceIdentifier.of = of;
    /** Check wether or not the provided object is a ServiceIdentifier */
    function is(target) {
        return serviceIdentityTag.has(target);
    }
    ServiceIdentifier.is = is;
})(ServiceIdentifier || (ServiceIdentifier = {}));
function create(tag, options) {
    const id = ((target, _, index) => {
        ServiceIdentifier.registry.addDependency(target, id, index, "required");
    });
    serviceIdentityTag.set(id, tag);
    Object.assign(id, createImpl(id, options));
    ServiceIdentifier.registry.add(id, options);
    return id;
}
function createImpl(id, options) {
    return {
        toString: () => options.name
    };
}function isAllowedScope(scope, owned) {
    if (owned) {
        return (scope & 1 /* ServiceScope.container */) === 1 /* ServiceScope.container */;
    }
    return (scope & 2 /* ServiceScope.children */) === 2 /* ServiceScope.children */;
}
function resolveServiceId(serviceIdOrCtor) {
    if (ServiceIdentifier.is(serviceIdOrCtor)) {
        return serviceIdOrCtor;
    }
    const serviceId = ServiceIdentifier.registry.resolve(serviceIdOrCtor);
    if (serviceId)
        return serviceId;
    throw new Error(`${serviceIdOrCtor} is neither a service id, neither a valid registered constructor.`);
}const _serviceContractTag = Tag("serviceContract");
function ServiceContract(serviceId) {
    return (target) => {
        _serviceContractTag.set(target, serviceId);
    };
}
(function (ServiceContract) {
    ServiceContract.Tag = _serviceContractTag.readOnly();
    function resolve(ctor) {
        var _a;
        return (_a = _serviceContractTag.get(ctor)) !== null && _a !== void 0 ? _a : ServiceIdentifier.registry.resolve(ctor);
    }
    ServiceContract.resolve = resolve;
})(ServiceContract || (ServiceContract = {}));/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};const IServiceAccessor = ServiceIdentifier("IServiceAccessor");function Optional(serviceId) {
    return (target, _, index) => {
        ServiceIdentifier.registry.addDependency(target, serviceId, index, "optional");
    };
}
function Many(serviceId) {
    return (target, _, index) => {
        ServiceIdentifier.registry.addDependency(target, serviceId, index, "many");
    };
}const _serviceFactoryTag = Tag("serviceFactory");
const ServiceFactoryTag = _serviceFactoryTag.readOnly();
var IServiceFactory;
(function (IServiceFactory) {
    function create(serviceId, callback, targetType) {
        let CallbackServiceFactory = class CallbackServiceFactory extends DisposableHost {
            constructor(_serviceAccessor) {
                super();
                this._serviceAccessor = _serviceAccessor;
                this.registerForDispose(_serviceAccessor);
            }
            create() {
                return callback(this._serviceAccessor);
            }
        };
        CallbackServiceFactory.targetType = targetType !== null && targetType !== void 0 ? targetType : Object;
        CallbackServiceFactory = __decorate([
            ServiceFactory(serviceId),
            __param(0, Optional(IServiceAccessor))
        ], CallbackServiceFactory);
        return CallbackServiceFactory;
    }
    IServiceFactory.create = create;
})(IServiceFactory || (IServiceFactory = {}));
const ServiceFactory = (serviceId) => {
    return (target) => {
        _serviceFactoryTag.set(target, serviceId);
    };
};class ServiceCollection extends DisposableHost {
    get size() { return this._store.size; }
    constructor(descriptors = []) {
        super();
        const values = ServiceCollection.entries(descriptors);
        this._store = Lookup.create(values, ServiceIdentityTag.get);
    }
    has(serviceIdOrDescriptor) {
        if (ServiceIdentifier.is(serviceIdOrDescriptor)) {
            return this._store.has(serviceIdOrDescriptor);
        }
        const desc = serviceIdOrDescriptor;
        return this._store.hasValue(desc.serviceId, desc);
    }
    get(serviceId) {
        return this._store.get(serviceId);
    }
    add(desc) {
        this._store.add(desc.serviceId, desc);
        return this;
    }
    delete(desc) {
        this._store.deleteValue(desc.serviceId, desc);
        return this;
    }
    *[Symbol.iterator]() {
        for (const desc of this._store.values()) {
            yield desc;
        }
    }
    dispose() {
        IDisposable.safeDispose(this._store);
    }
    static *entries(descriptors) {
        for (const desc of descriptors) {
            yield [desc.serviceId, desc];
        }
    }
}class CallbackIterator {
    constructor(initialValue, _nextCallback) {
        this._nextCallback = _nextCallback;
        this._nextValue = initialValue;
    }
    next() {
        const value = this._nextValue;
        if (typeof value === "undefined") {
            return { value, done: true };
        }
        this._nextValue = this._nextCallback(value);
        return { value, done: false };
    }
}var Iterables;
(function (Iterables) {
    function cast(iterable) {
        return typeof iterable === "object" && iterable !== null
            && typeof Reflect.get(iterable, Symbol.iterator) === "function";
    }
    Iterables.cast = cast;
    function create(initialValue, nextCallback) {
        return {
            [Symbol.iterator]: () => {
                return new CallbackIterator(initialValue, nextCallback);
            }
        };
    }
    Iterables.create = create;
    function* filter(iterable, predicate) {
        for (const item of iterable)
            if (predicate(item))
                yield item;
    }
    Iterables.filter = filter;
    function has(iterable, filterPredicate) {
        for (const _ of build(iterable, filterPredicate))
            return true;
        return false;
    }
    Iterables.has = has;
    function first(iterable, filterPredicate) {
        for (const item of build(iterable, filterPredicate))
            return item;
    }
    Iterables.first = first;
    function last(iterable, filterPredicate) {
        const iterator = build(iterable, filterPredicate);
        let result;
        for (const item of iterator) {
            result = item;
        }
        return result;
    }
    Iterables.last = last;
    function build(iterable, filterPredicate) {
        filterPredicate !== null && filterPredicate !== void 0 ? filterPredicate : (filterPredicate = _ => true);
        return filter(iterable, filterPredicate);
    }
})(Iterables || (Iterables = {}));var Iterators;
(function (Iterators) {
    function create(initialValue, nextCallback) {
        return new CallbackIterator(initialValue, nextCallback);
    }
    Iterators.create = create;
})(Iterators || (Iterators = {}));class TopologicalIterator {
    constructor(src, _resolver, hashFactory) {
        this._resolver = _resolver;
        this._resolveds = new HashSet();
        this._remaings = new HashMap(hashFactory, [...src].map(item => [item, [...this._resolver(item)]]));
    }
    next() {
        if (!this._remaings.size)
            return { value: void 0, done: true };
        for (let [node, deps] of this._remaings) {
            if (deps.every(d => this._resolveds.has(d))) {
                this._remaings.delete(node);
                this._resolveds.add(node);
                return { value: node, done: false };
            }
        }
        throw new Error(`Cyclic dependencies: Cannot resolve the provided dependency graph.`);
    }
}class TopologicalGraph {
    constructor(_hashFactory) {
        this._hashFactory = _hashFactory;
        this._nodes = new HashMap(_hashFactory);
    }
    has(node) {
        return this._nodes.has(node);
    }
    *get(node) {
        let deps = this._nodes.get(node);
        if (deps)
            yield* deps;
    }
    add(node, ...dependencies) {
        let deps = this._nodes.get(node);
        if (deps) {
            for (let dep of dependencies)
                deps.add(dep);
        }
        else {
            this._nodes.set(node, new HashSet(this._hashFactory, dependencies));
        }
    }
    delete(node) {
        return this._nodes.delete(node);
    }
    clear() {
        this._nodes.clear();
    }
    *nodes() {
        const keys = [...this._nodes.keys()];
        const results = new HashSet(this._hashFactory, keys);
        // Nodes without dependencies are returned first
        for (const values of this._nodes.values()) {
            for (const dep of values) {
                if (!results.has(dep)) {
                    results.add(dep);
                    yield dep;
                }
            }
        }
        // Last added supposedly have less dependencies
        yield* keys.reverse();
    }
    [Symbol.iterator]() {
        return new TopologicalIterator(this.nodes(), n => this.get(n), this._hashFactory);
    }
}class ServiceDescriptor {
    constructor(serviceId, lifetime, scope, ctor, baseArgs, delayed) {
        this.serviceId = serviceId;
        this.lifetime = lifetime;
        this.scope = scope;
        this.ctor = ctor;
        this.baseArgs = baseArgs;
        this.delayed = delayed;
        this.targetType = ctor;
        this.validateArgs();
    }
    validateArgs() {
        const dependencies = ServiceIdentifier.registry.dependencies(this.targetType);
        const first = Iterables.first(dependencies);
        if (first) {
            if (first.index > this.baseArgs.length) {
                throw new Error(`Not enough arguments provided for service binding ${this.serviceId}. Provided: ${this.baseArgs.length}, Expected: ${first.index}`);
            }
            if (first.index < this.baseArgs.length) {
                throw new Error(`Too much arguments provided for service binding ${this.serviceId}. Provided: ${this.baseArgs.length}, Expected: ${first.index}`);
            }
        }
    }
}class ServiceFactoryDescriptor {
    constructor(serviceId, lifetime, scope, ctor, baseArgs, delayed) {
        this.serviceId = serviceId;
        this.lifetime = lifetime;
        this.scope = scope;
        this.ctor = ctor;
        this.baseArgs = baseArgs;
        this.delayed = delayed;
        this.targetType = ctor.targetType;
    }
}function createServiceDescriptor(serviceId, lifetime, ctor, { baseArgs = [], delayed = false, scope = 3 /* ServiceScope.both */ }) {
    return new ServiceDescriptor(serviceId, lifetime, scope, ctor, baseArgs, delayed);
}
function tryAddServiceInternal$1($this, lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    var _a;
    if (ServiceIdentifier.is(servicerIdOrCtor)) {
        if ($this.has(servicerIdOrCtor))
            return $this;
        return $this.add(createServiceDescriptor(servicerIdOrCtor, lifetime, ctorOrOptions, options !== null && options !== void 0 ? options : {}));
    }
    const serviceId = ServiceContract.resolve(servicerIdOrCtor);
    if ($this.has(serviceId))
        return $this;
    return $this.add(createServiceDescriptor(serviceId, lifetime, servicerIdOrCtor, (_a = ctorOrOptions) !== null && _a !== void 0 ? _a : {}));
}
function addServiceInternal$1($this, lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    var _a;
    if (ServiceIdentifier.is(servicerIdOrCtor)) {
        return $this.add(createServiceDescriptor(servicerIdOrCtor, lifetime, ctorOrOptions, options !== null && options !== void 0 ? options : {}));
    }
    const serviceId = ServiceContract.resolve(servicerIdOrCtor);
    return $this.add(createServiceDescriptor(serviceId, lifetime, servicerIdOrCtor, (_a = ctorOrOptions) !== null && _a !== void 0 ? _a : {}));
}
function addService(lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal$1(this, lifetime, servicerIdOrCtor, ctorOrOptions, options);
}
function addScoped(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal$1(this, 1 /* ServiceLifetime.scoped */, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddScoped(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal$1(this, 1 /* ServiceLifetime.scoped */, servicerIdOrCtor, ctorOrOptions, options);
}
function addSingleton(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal$1(this, 2 /* ServiceLifetime.singleton */, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddSingleton(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal$1(this, 2 /* ServiceLifetime.singleton */, servicerIdOrCtor, ctorOrOptions, options);
}
function addTransient(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal$1(this, 0 /* ServiceLifetime.transient */, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddTransient(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal$1(this, 0 /* ServiceLifetime.transient */, servicerIdOrCtor, ctorOrOptions, options);
}
Object.assign(ServiceCollection.prototype, {
    addService,
    addScoped, tryAddScoped,
    addSingleton, tryAddSingleton,
    addTransient, tryAddTransient
});function createServiceFactoryDescriptor(serviceId, lifetime, ctor, { baseArgs = [], delayed = false, scope = 3 /* ServiceScope.both */ }) {
    return new ServiceFactoryDescriptor(serviceId, lifetime, scope, ctor, baseArgs, delayed);
}
function tryAddServiceInternal($this, lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    var _a;
    if (ServiceIdentifier.is(servicerIdOrCtor)) {
        if ($this.has(servicerIdOrCtor))
            return $this;
        return $this.add(createServiceFactoryDescriptor(servicerIdOrCtor, lifetime, ctorOrOptions, options !== null && options !== void 0 ? options : {}));
    }
    const serviceId = ServiceFactoryTag.get(servicerIdOrCtor);
    assertServiceFactoryId(serviceId);
    if ($this.has(serviceId))
        return $this;
    return $this.add(createServiceFactoryDescriptor(serviceId, lifetime, servicerIdOrCtor, (_a = ctorOrOptions) !== null && _a !== void 0 ? _a : {}));
}
function addServiceInternal($this, lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    var _a;
    if (ServiceIdentifier.is(servicerIdOrCtor)) {
        return $this.add(createServiceFactoryDescriptor(servicerIdOrCtor, lifetime, ctorOrOptions, options !== null && options !== void 0 ? options : {}));
    }
    const serviceId = ServiceFactoryTag.get(servicerIdOrCtor);
    assertServiceFactoryId(serviceId);
    return $this.add(createServiceFactoryDescriptor(serviceId, lifetime, servicerIdOrCtor, (_a = ctorOrOptions) !== null && _a !== void 0 ? _a : {}));
}
function assertServiceFactoryId(serviceId) {
    if (!serviceId)
        throw new Error("No service id attached to the provided factory. Use the @ServiceFactory decorator or provide explicitly the service id");
}
function addServiceFactory(lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal(this, lifetime, servicerIdOrCtor, ctorOrOptions, options);
}
function addScopedFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal(this, 1 /* ServiceLifetime.scoped */, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddScopedFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal(this, 1 /* ServiceLifetime.scoped */, servicerIdOrCtor, ctorOrOptions, options);
}
function addSingletonFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal(this, 2 /* ServiceLifetime.singleton */, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddSingletonFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal(this, 2 /* ServiceLifetime.singleton */, servicerIdOrCtor, ctorOrOptions, options);
}
function addTransientFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal(this, 0 /* ServiceLifetime.transient */, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddTransientFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal(this, 0 /* ServiceLifetime.transient */, servicerIdOrCtor, ctorOrOptions, options);
}
Object.assign(ServiceCollection.prototype, {
    addServiceFactory,
    addScopedFactory, tryAddScopedFactory,
    addSingletonFactory, tryAddSingletonFactory,
    addTransientFactory, tryAddTransientFactory
});function addInstance(servicerIdOrInstance, instanceOrOptions, options = {}) {
    let instance;
    let serviceId;
    if (ServiceIdentifier.is(servicerIdOrInstance)) {
        serviceId = servicerIdOrInstance;
        instance = instanceOrOptions;
    }
    else {
        instance = servicerIdOrInstance;
        serviceId = resolveServiceId(instance.constructor);
    }
    const { delayed = false, scope = 3 /* ServiceScope.both */ } = options;
    class CustomInstanceServiceFactory {
        create() { return instance; }
    }
    CustomInstanceServiceFactory.targetType = instance.constructor;
    const desc = new ServiceFactoryDescriptor(serviceId, 2 /* ServiceLifetime.singleton */, scope, CustomInstanceServiceFactory, [], delayed);
    return this.add(desc);
}
Object.assign(ServiceCollection.prototype, {
    addInstance
});const IServiceProvider = ServiceIdentifier("IServiceProvider");const ProxyInstance = Symbol();
class ServiceProxy extends DisposableHost {
    get proxy() { return this._proxy; }
    constructor(service) {
        super();
        const { proxy, revoke } = Proxy.revocable(service, this);
        this._proxy = proxy;
        this._service = service;
        this._revoke = revoke;
    }
    has(target, p) {
        return p in target;
    }
    get(target, p) {
        if (p === ProxyInstance)
            return this._service;
        const value = target[p];
        if (typeof value === "function") {
            return (...args) => {
                const r = value.apply(target, args);
                return r === target ? this._proxy : r;
            };
        }
        return value;
    }
    set(target, p, value) {
        target[p] = value;
        return true;
    }
    deleteProperty(target, p) {
        delete target[p];
        return true;
    }
    getPrototypeOf(target) {
        return Object.getPrototypeOf(target);
    }
    dispose() {
        this._revoke();
    }
}let ServiceAccessor = class ServiceAccessor extends DisposableHost {
    constructor(_serviceProvider) {
        super();
        this._serviceProvider = _serviceProvider;
        this._proxies = new HashMap();
    }
    get(serviceId, required) {
        this.checkIfDisposed();
        const instance = this._serviceProvider.get(serviceId, required);
        if (instance)
            return this.getProxy(instance);
    }
    *getMany(serviceId, currentScopeOnly) {
        this.checkIfDisposed();
        for (const instance of this._serviceProvider.getAll(serviceId, currentScopeOnly)) {
            yield this.getProxy(instance);
        }
    }
    getProxy(instance) {
        const serviceProxy = this._proxies.getOrSet(instance, () => new ServiceProxy(instance));
        return serviceProxy === null || serviceProxy === void 0 ? void 0 : serviceProxy.proxy;
    }
    dispose() {
        const proxies = this._proxies.values();
        IDisposable.safeDisposeAll(proxies);
    }
};
ServiceAccessor = __decorate([
    ServiceContract(IServiceAccessor),
    __param(0, IServiceProvider)
], ServiceAccessor);const IDependencyResolver = ServiceIdentifier("IDependencyResolver");const IInstantiationService = ServiceIdentifier("IInstantiationService");class AsyncEventIterator {
    constructor(target, queueMaxSize) {
        this._handle = target(this.onDidEventEmitted, this);
        this._queueMaxSize = queueMaxSize;
        this._next = null;
        this._pendingQueue = [];
    }
    onDidEventEmitted(...args) {
        const next = this._next;
        if (next) {
            this._next = null;
            next(args);
        }
        else if (this._pendingQueue) {
            if (this._queueMaxSize !== -1 && this._pendingQueue.length >= this._queueMaxSize) {
                throw new Error(`Event iterator queue max size reached: ${this._queueMaxSize} are pending`);
            }
            this._pendingQueue.push(args);
        }
    }
    next() {
        if (!this._pendingQueue)
            throw new Error("Cannot reuse a terminated iterator");
        if (this._pendingQueue.length) {
            return Promise.resolve({
                value: this._pendingQueue.shift(),
                done: false
            });
        }
        return new Promise(resolve => {
            this._next = (args) => {
                resolve({
                    value: args,
                    done: false
                });
            };
        });
    }
    async return() {
        this.dispose();
        return {
            value: null,
            done: true
        };
    }
    [IDisposable.dispose]() {
        if (this._handle) {
            this.dispose();
        }
    }
    dispose() {
        IDisposable.safeDispose(this._handle);
        this._handle = null;
        this._pendingQueue = null;
    }
}var IEvent;
(function (IEvent) {
    function create(emitter) {
        const event = ((handler, thisArgs) => {
            handler = thisArgs ? handler.bind(thisArgs) : handler;
            emitter.addHandler(handler);
            const result = IDisposable.create(() => emitter.removeHandler(handler));
            if (thisArgs instanceof DisposableHost) {
                thisArgs.registerForDispose(result);
            }
            return result;
        });
        Reflect.set(event, Symbol.asyncIterator, () => new AsyncEventIterator(event, emitter.iteratorQueueMaxSize));
        if (emitter.async)
            Reflect.set(event, "async", true);
        return event;
    }
    IEvent.create = create;
    /**
     * Returns the next event arguments passed to the provided event
     * @param event Event to listen
     * @returns Arguments passed to the emitter
     */
    function next(event) {
        return new Promise((f) => {
            const handler = event.async
                ? event(async (...args) => {
                    IDisposable.safeDispose(handler);
                    f(args);
                })
                : event((...args) => {
                    IDisposable.safeDispose(handler);
                    f(args);
                });
        });
    }
    IEvent.next = next;
    /**
     * Listen and trigger the provided callback once and remove imediatly the listener to avoir further calls
     * @param event Event to listen
     * @param callback Callback to call once
     * @param thisArgs This context
     */
    function once(event, callback, thisArgs) {
        const handler = event.async
            ? event(async (...args) => {
                IDisposable.safeDispose(handler);
                await callback.call(thisArgs, ...args);
            })
            : event((...args) => {
                IDisposable.safeDispose(handler);
                callback.call(thisArgs, ...args);
            });
    }
    IEvent.once = once;
})(IEvent || (IEvent = {}));const Memoize = (_, propertyKey, desc) => {
    if (typeof (desc === null || desc === void 0 ? void 0 : desc.get) !== "function") {
        throw new Error(`Invalid "@Memoize" target: "${String(propertyKey)}" is not a get accessor.`);
    }
    desc.get = createGetter(propertyKey, desc.get);
    delete desc.set;
};
function createGetter(propertyKey, valueFactory) {
    const privateProp = Symbol(String(propertyKey));
    return function () {
        if (!Reflect.has(this, privateProp)) {
            const value = valueFactory.apply(this);
            if (!Reflect.set(this, privateProp, value)) {
                console.warn(`"@Memoize" cannot work properly on following instance, cannot memoize the value`, this);
            }
            return value;
        }
        return Reflect.get(this, privateProp);
    };
}const MAX_LISTENERS = 16;
const DISABLED_MAX = -1;
class EventEmitterBase extends DisposableHost {
    get size() { return this._handlers ? this._handlers.length : 0; }
    get maxSize() { var _a; return (_a = this._maxSize) !== null && _a !== void 0 ? _a : MAX_LISTENERS; }
    get iteratorQueueMaxSize() { var _a; return (_a = this._iteratorQueueMaxSize) !== null && _a !== void 0 ? _a : DISABLED_MAX; }
    constructor(options) {
        super();
        if (options) {
            if (typeof options.maxSize === "number") {
                this._maxSize = options.maxSize;
            }
            if (typeof options.iteratorQueueMaxSize === "number") {
                this._iteratorQueueMaxSize = options.iteratorQueueMaxSize;
            }
        }
    }
    *handlers() {
        if (this._handlers) {
            yield* this._handlers;
        }
    }
    addHandler(handler) {
        this.checkIfDisposed();
        if (this.maxSize !== DISABLED_MAX && this.size >= this.maxSize) {
            throw new Error(`Event max size reached: ${this.maxSize}`);
        }
        if (this._handlers) {
            this._handlers.push(handler);
        }
        else {
            this._handlers = [handler];
        }
    }
    removeHandler(handler) {
        if (this._handlers) {
            const idx = this._handlers.indexOf(handler);
            if (idx !== -1)
                this._handlers.splice(idx, 1);
        }
    }
    dispose() {
        delete this._handlers;
    }
}class EventEmitter extends EventEmitterBase {
    get event() { return IEvent.create(this); }
    emit(...args) {
        for (const callback of this.handlers()) {
            if (callback(...args) === false)
                break;
        }
    }
}
__decorate([
    Memoize
], EventEmitter.prototype, "event", null);class AsyncEventEmitter extends EventEmitterBase {
    get async() { return true; }
    get event() { return IEvent.create(this); }
    async emit(...args) {
        for (const callback of this.handlers()) {
            if (await callback(...args) === false)
                break;
        }
    }
}
__decorate([
    Memoize
], AsyncEventEmitter.prototype, "event", null);class InstantiationContext {
    constructor(target) {
        this.target = target;
        this._instances = new HashMap(e => e.uid);
    }
    setInstance(entry, instance) {
        this._instances.set(entry, instance);
    }
    getInstance(entry) {
        return this._instances.get(entry);
    }
}var ServiceEntry;
(function (ServiceEntry) {
    function create(desc, provider) {
        const uid = `${Tags.hashId(desc)}-${Tags.hashId(provider)}`;
        return { uid, desc, provider };
    }
    ServiceEntry.create = create;
    function getScopeInstance({ desc, provider }) {
        return provider.getOwnInstance(desc);
    }
    ServiceEntry.getScopeInstance = getScopeInstance;
})(ServiceEntry || (ServiceEntry = {}));class InstantiationError extends Error {
    constructor(serviceId, err) {
        super(`Error during service instanciation for service id: ${serviceId}`, { cause: err });
    }
}let InstantiationService = class InstantiationService {
    get onDidServiceInstantiated() { return this._onDidServiceInstantiated.event; }
    constructor(_dependencyResolver) {
        this._dependencyResolver = _dependencyResolver;
        this._onDidServiceInstantiated = new EventEmitter();
    }
    createService(desc) {
        const entry = this._dependencyResolver.resolveEntry(desc);
        if (entry) {
            if (!entry.desc.delayed) {
                return this.createServiceCore(entry);
            }
            return this.createDelayedService(entry);
        }
    }
    createServiceCore(entry) {
        const ctx = this.instanciateDependencyGraph(entry);
        return ctx.getInstance(entry);
    }
    createDelayedService(entry) {
        const lazyValue = new Lazy(() => this.createServiceCore(entry), entry.desc.ctor);
        const proxy = lazyValue.get();
        this.onInstanceCreated(entry.desc, proxy);
        return proxy;
    }
    instanciateService(entry, ctx) {
        const instance = entry.desc.delayed && ctx.target.uid !== entry.uid
            ? this.createDelayedService(entry)
            : this.createServiceInstance(entry, ctx);
        ctx.setInstance(entry, instance);
    }
    instanciateDependencyGraph(entry) {
        const graph = this._dependencyResolver.resolveDependencyGraph(entry);
        const ctx = new InstantiationContext(entry);
        const resolved = new Set();
        for (const node of graph.nodes()) {
            const instance = ServiceEntry.getScopeInstance(node);
            if (instance) {
                ctx.setInstance(node, instance);
                resolved.add(node);
            }
            else if (node.desc.delayed) {
                this.instanciateDependency(node, ctx);
                resolved.add(node);
            }
        }
        for (const node of graph) {
            if (resolved.has(node) && node.uid !== entry.uid)
                continue;
            this.instanciateDependency(node, ctx);
        }
        return ctx;
    }
    instanciateDependency(entry, ctx) {
        const instantiationSvc = entry.provider.get(IInstantiationService, true);
        instantiationSvc.instanciateService(entry, ctx);
    }
    createServiceInstance(entry, ctx) {
        asserts.defined(entry.dependencies);
        const dependencies = entry.dependencies.map(dep => dep.resolveArg(ctx));
        let instance = this.createInstance(entry.desc.serviceId, entry.desc.ctor, [...entry.desc.baseArgs, ...dependencies]);
        if (entry.desc instanceof ServiceFactoryDescriptor) {
            const factory = instance;
            const lazyValue = new Lazy(() => {
                const instance = factory.create();
                try {
                    if (instance instanceof Promise) {
                        throw new Error(`ServiceFactory cannot return async results (${entry.desc.serviceId}`);
                    }
                }
                finally {
                    IDisposable.safeDispose(factory);
                }
                this.onInstanceCreated(entry.desc, instance);
                return instance;
            }, entry.desc.targetType);
            instance = lazyValue.get();
        }
        this.onInstanceCreated(entry.desc, instance);
        return instance;
    }
    createInstance(serviceId, ctor, args) {
        try {
            return new ctor(...args);
        }
        catch (err) {
            if (err instanceof Error) {
                throw new InstantiationError(serviceId, err);
            }
            else {
                const wrap = new Error(String(err));
                throw new InstantiationError(serviceId, wrap);
            }
        }
    }
    onInstanceCreated(desc, instance) {
        this._onDidServiceInstantiated.emit(desc, instance);
    }
};
InstantiationService = __decorate([
    ServiceContract(IInstantiationService),
    __param(0, IDependencyResolver)
], InstantiationService);class EmptyServiceDependency {
    constructor(param) {
        this.param = param;
    }
    resolveArg(_ctx) { }
    *entries() { }
}
class SingleServiceDependency {
    constructor(param, _entry) {
        this.param = param;
        this._entry = _entry;
    }
    resolveArg(ctx) {
        if (ctx) {
            return ctx.getInstance(this._entry);
        }
        return this._entry.provider.get(this._entry.desc);
    }
    getDependencyArg(_ctx) { }
    *entries() {
        yield this._entry;
    }
}
class MultipleServiceDependency {
    constructor(param, entries) {
        this.param = param;
        this._entries = [...entries];
    }
    resolveArg(ctx) {
        if (ctx) {
            return this._entries.map(e => ctx.getInstance(e));
        }
        return this._entries.map(e => e.provider.get(e.desc));
    }
    *entries() {
        yield* this._entries;
    }
}let DependencyResolver = class DependencyResolver {
    constructor(_serviceProvider) {
        this._serviceProvider = _serviceProvider;
    }
    *resolveProviders(serviceId) {
        for (const svc of Iterables.create(this._serviceProvider, prev => prev.parent())) {
            const descriptors = svc.getOwnDescriptors(serviceId);
            if (Iterables.has(descriptors)) {
                yield svc;
            }
        }
    }
    resolveEntry(descriptorOrId) {
        if (ServiceIdentifier.is(descriptorOrId)) {
            const all = this.resolveEntries(descriptorOrId);
            return Iterables.first(all);
        }
        else {
            const all = this.resolveEntries(descriptorOrId.serviceId);
            return Iterables.first(all, entry => entry.desc === descriptorOrId);
        }
    }
    *resolveEntries(serviceId) {
        for (const svc of Iterables.create(this._serviceProvider, prev => prev.parent())) {
            for (const desc of svc.getOwnDescriptors(serviceId)) {
                if (isAllowedScope(desc.scope, svc === this._serviceProvider)) {
                    const provider = desc.lifetime === 1 /* ServiceLifetime.scoped */ ? this._serviceProvider : svc;
                    yield ServiceEntry.create(desc, provider);
                }
            }
        }
    }
    *resolveDependencies(ctor) {
        for (const param of ServiceIdentifier.registry.dependencies(ctor)) {
            if (param.type === "many") {
                const entries = this.resolveEntries(param.serviceId);
                yield new MultipleServiceDependency(param, entries);
            }
            else {
                const found = this.resolveEntry(param.serviceId);
                if (found) {
                    yield new SingleServiceDependency(param, found);
                }
                else if (param.type === "required") {
                    throw new Error(`No service named "${param.serviceId}" registered`);
                }
                else {
                    yield new EmptyServiceDependency(param);
                }
            }
        }
    }
    resolveDependencyGraph(entry) {
        const graph = new TopologicalGraph(entry => entry.uid);
        const stack = [entry];
        do {
            const entry = stack.pop();
            // Get the dependency resolver from the scope of the service
            const dependencyResolver = entry.provider.get(IDependencyResolver, true);
            const dependencies = [...dependencyResolver.resolveDependencies(entry.desc.ctor)];
            const serviceEntries = dependencies.flatMap(dep => [...dep.entries()]);
            graph.add(Object.assign(Object.assign({}, entry), { dependencies }), ...serviceEntries);
            const serviceToResolve = serviceEntries
                .filter(e => !graph.has(e) && !e.desc.delayed && !ServiceEntry.getScopeInstance(e));
            stack.push(...serviceToResolve);
        } while (stack.length);
        return graph;
    }
};
DependencyResolver = __decorate([
    ServiceContract(IDependencyResolver)
], DependencyResolver);let ServiceProvider = class ServiceProvider {
    constructor(_services, _parent) {
        this._services = _services;
        this._parent = _parent;
        this._instances = new Map();
        this._dependencyResolver = this.createDependencyResolver();
        this._instanciationService = this.createInstanciationService();
        this._instanciationService.onDidServiceInstantiated(this.onDidServiceInstantiated, this);
        this.addCoreService(IDependencyResolver, this._dependencyResolver);
        this.addCoreService(IInstantiationService, this._instanciationService);
        this.addCoreService(IServiceProvider, this);
    }
    createDependencyResolver() {
        return new DependencyResolver(this);
    }
    createInstanciationService() {
        return new InstantiationService(this._dependencyResolver);
    }
    addCoreService(serviceId, instance) {
        const desc = new ServiceDescriptor(serviceId, 1 /* ServiceLifetime.scoped */, 1 /* ServiceScope.container */, instance.constructor, [], false);
        this._services.add(desc);
        this._instances.set(desc, instance);
    }
    onDidServiceInstantiated(desc, instance) {
        if (desc.lifetime !== 0 /* ServiceLifetime.transient */) {
            this._instances.set(desc, instance);
        }
    }
    createInstance(ctor, ...baseArgs) {
        const args = this.resolveArgs(ctor, baseArgs);
        return new ctor(...args);
    }
    resolve(ctor) {
        const resolveArgs = (baseArgs) => this.resolveArgs(ctor, baseArgs);
        return class extends ctor {
            constructor(...baseArgs) {
                super(...resolveArgs(baseArgs));
                this.injectedCallback && this.injectedCallback();
            }
        };
    }
    *resolveArgs(ctor, baseArgs) {
        const dependencies = [...this._dependencyResolver.resolveDependencies(ctor)];
        if (!dependencies.length)
            return baseArgs;
        const [first] = dependencies;
        if (baseArgs.length !== first.param.index) {
            throw new Error(`Invalid base arguments, expected ${first.param.index} arguments, provided ${baseArgs.length}`);
        }
        yield* baseArgs;
        for (const dependency of dependencies) {
            yield dependency.resolveArg();
        }
    }
    parent() {
        return this._parent;
    }
    getOwnDescriptors(serviceId) {
        return this._services.get(serviceId);
    }
    getOwnInstance(desc) {
        return this._instances.get(desc);
    }
    get(descriptorOrId, required = false, currentScopeOnly = false) {
        // Owned descriptor
        if (ServiceIdentifier.is(descriptorOrId)) {
            const descriptors = this._services.get(descriptorOrId);
            const first = Iterables.first(descriptors);
            if (first) {
                return this.fetchOrCreateOwnInstance(first, required, true);
            }
        }
        else if (this._services.has(descriptorOrId)) {
            return this.fetchOrCreateOwnInstance(descriptorOrId, required, true);
        }
        if (!currentScopeOnly) {
            // Not owned descriptor
            const entry = this._dependencyResolver.resolveEntry(descriptorOrId);
            if (entry) {
                return entry.provider.fetchOrCreateOwnInstance(entry.desc, required, false);
            }
        }
        if (required)
            throw new Error(`No binding found for "${descriptorOrId}" from current scope.`);
    }
    *getAll(serviceId, currentScopeOnly) {
        if (currentScopeOnly) {
            const descriptors = this._services.get(serviceId);
            yield* this.fetchOrCreateOwnInstances(descriptors);
        }
        else {
            for (const provider of this._dependencyResolver.resolveProviders(serviceId)) {
                if (provider === this) {
                    const descriptors = this._services.get(serviceId);
                    yield* this.fetchOrCreateOwnInstances(descriptors);
                }
                else {
                    const descriptors = Iterables.filter(this._services.get(serviceId), x => (x.scope & 2 /* ServiceScope.children */) === 2 /* ServiceScope.children */);
                    yield* this.fetchOrCreateOwnInstances(descriptors);
                }
            }
        }
    }
    fetchOrCreateOwnInstance(descriptor, required, owned) {
        if (isAllowedScope(descriptor.scope, owned)) {
            const instance = this.getOwnInstance(descriptor);
            if (!instance) {
                return this._instanciationService.createService(descriptor);
            }
            return instance;
        }
        else if (required) {
            throw new Error(`Attempting to create an instance of service scoped to children only: "${descriptor}".`);
        }
    }
    *fetchOrCreateOwnInstances(descriptors) {
        for (const descriptor of descriptors) {
            const instance = this.fetchOrCreateOwnInstance(descriptor, false, true);
            if (typeof instance !== "undefined")
                yield instance;
        }
    }
    [Symbol.dispose]() {
        const instances = [...this._instances.values()];
        this._instances.clear();
        IDisposable.safeDisposeAll(instances);
    }
};
ServiceProvider = __decorate([
    ServiceContract(IServiceProvider)
], ServiceProvider);const IIoCModule = ServiceIdentifier("IIoCModule");
var IoCModuleSetupResultBehavior;
(function (IoCModuleSetupResultBehavior) {
    IoCModuleSetupResultBehavior[IoCModuleSetupResultBehavior["continue"] = 0] = "continue";
    IoCModuleSetupResultBehavior[IoCModuleSetupResultBehavior["stop"] = 1] = "stop";
})(IoCModuleSetupResultBehavior || (IoCModuleSetupResultBehavior = {}));
var IoCModuleSetupExecBehavior;
(function (IoCModuleSetupExecBehavior) {
    IoCModuleSetupExecBehavior[IoCModuleSetupExecBehavior["blocking"] = 0] = "blocking";
    IoCModuleSetupExecBehavior[IoCModuleSetupExecBehavior["asynchronous"] = 1] = "asynchronous";
})(IoCModuleSetupExecBehavior || (IoCModuleSetupExecBehavior = {}));var SetupErrorHandlerResult;
(function (SetupErrorHandlerResult) {
    SetupErrorHandlerResult[SetupErrorHandlerResult["stop"] = 0] = "stop";
    SetupErrorHandlerResult[SetupErrorHandlerResult["continue"] = 1] = "continue";
    SetupErrorHandlerResult[SetupErrorHandlerResult["throw"] = 2] = "throw";
})(SetupErrorHandlerResult || (SetupErrorHandlerResult = {}));
class SafeIoCModuleSetupAction {
    constructor() {
        this._execBehavior = IoCModuleSetupExecBehavior.blocking;
    }
    get execBehavior() { return this._execBehavior; }
    async exec(provider, token) {
        var _a;
        try {
            await this.execImpl(provider, token);
            return IoCModuleSetupResultBehavior.continue;
        }
        catch (err) {
            const behavior = (_a = this._errorHandler) === null || _a === void 0 ? void 0 : _a.call(this, err, provider);
            switch (behavior) {
                case undefined:
                case true:
                case SetupErrorHandlerResult.continue:
                    return IoCModuleSetupResultBehavior.continue;
                case SetupErrorHandlerResult.stop:
                case false:
                    return IoCModuleSetupResultBehavior.stop;
                case SetupErrorHandlerResult.throw:
                    throw err;
                default:
                    throw new Error("Invalid result");
            }
        }
    }
    continueWithoutAwaiting() {
        this._execBehavior = IoCModuleSetupExecBehavior.asynchronous;
    }
    onError(errorHandler) {
        this._errorHandler = errorHandler;
    }
}class IoCModuleCallbackSetupAction extends SafeIoCModuleSetupAction {
    constructor(_action) {
        super();
        this._action = _action;
    }
    async execImpl(provider, token) {
        const acc = provider.get(IServiceAccessor, true);
        await this._action(acc, token);
    }
}class IoCModuleServiceSetupAction extends SafeIoCModuleSetupAction {
    constructor(_serviceId, _action, _required) {
        super();
        this._serviceId = _serviceId;
        this._action = _action;
        this._required = _required;
    }
    async execImpl(provider, token) {
        const svc = provider.get(this._serviceId, this._required);
        if (svc)
            await this._action(svc, token);
    }
}class IoCModuleManyServiceSetupAction extends SafeIoCModuleSetupAction {
    constructor(_serviceId, _action, _currentScopeOnly) {
        super();
        this._serviceId = _serviceId;
        this._action = _action;
        this._currentScopeOnly = _currentScopeOnly;
    }
    async execImpl(provider, token) {
        const services = [...provider.getAll(this._serviceId, this._currentScopeOnly)];
        const all = services.map(x => this._action(x));
        await Promise.all(all);
    }
}let SetupIoCContainerBuilder$1=class SetupIoCContainerBuilder {
    constructor(_wrapped, _action) {
        this._wrapped = _wrapped;
        this._action = _action;
    }
    continueWithoutAwaiting() {
        this._action.continueWithoutAwaiting();
        return this._wrapped;
    }
    catch(errorHandler) {
        this._action.onError(errorHandler);
        return this._wrapped;
    }
    use(action) {
        return this._wrapped.use(action);
    }
    setup(serviceIdOrCtor, action, required = true) {
        return this._wrapped.setup(serviceIdOrCtor, action, required);
    }
    setupMany(serviceIdOrCtor, action, currentScopeOnly = true) {
        return this._wrapped.setupMany(serviceIdOrCtor, action, currentScopeOnly);
    }
    configure(action) {
        return this._wrapped.configure(action);
    }
    build() {
        return this._wrapped.build();
    }
};class IoCContainerBuilder extends DisposableHost {
    constructor(_name) {
        super();
        this._name = _name;
        this._setups = [];
        this._services = new ServiceCollection();
    }
    configure(action) {
        action(this._services);
        return this;
    }
    use(action) {
        this.checkIfDisposed();
        const setupAction = new IoCModuleCallbackSetupAction(action);
        return this.addSafeSetupAction(setupAction);
    }
    setup(serviceIdOrCtor, action, required = true) {
        this.checkIfDisposed();
        const serviceId = resolveServiceId(serviceIdOrCtor);
        const setupAction = new IoCModuleServiceSetupAction(serviceId, action, required);
        return this.addSafeSetupAction(setupAction);
    }
    setupMany(serviceIdOrCtor, action, currentScopeOnly = true) {
        this.checkIfDisposed();
        const serviceId = resolveServiceId(serviceIdOrCtor);
        const setupAction = new IoCModuleManyServiceSetupAction(serviceId, action, currentScopeOnly);
        return this.addSafeSetupAction(setupAction);
    }
    addSafeSetupAction(setupAction) {
        this._setups.push(setupAction);
        return new SetupIoCContainerBuilder$1(this, setupAction);
    }
    build() {
        this.checkIfDisposed();
        const services = new ServiceCollection(this._services);
        const provider = this.createServiceProvider(services);
        this.configureDefaultServices && this.configureDefaultServices(services, provider);
        const module = this.createModule(this._name, provider, [...this._setups]);
        services.addInstance(IIoCModule, module);
        return module;
    }
}class DeferredError extends Error {
}
class Deferred {
    constructor() {
        this._state = 0;
        this._version = 0;
    }
    get version() { return this._version; }
    get idle() { return this._state === 0; }
    get completed() { return Boolean(this._state & 1 /* DeferredState.completed */); }
    get succeed() { return Boolean(this._state & 4 /* DeferredState.succeed */); }
    get faulted() { return Boolean(this._state & 2 /* DeferredState.faulted */); }
    get disposed() { return Boolean(this._state & 8 /* DeferredState.disposed */); }
    resolve(value) {
        IDisposable.checkDisposed(this);
        if (!this._state) {
            this._state = 1 /* DeferredState.completed */ | 4 /* DeferredState.succeed */;
            this._promiseOrResult = value;
            this._resolveCallback && this._resolveCallback(value);
            return true;
        }
        return false;
    }
    reject(reason) {
        IDisposable.checkDisposed(this);
        if (!this._state) {
            this._state = 1 /* DeferredState.completed */ | 2 /* DeferredState.faulted */;
            const error = reason instanceof Error ? reason : new DeferredError(reason);
            this._promiseOrResult = error;
            this._rejectCallback && this._rejectCallback(error);
            return true;
        }
        return false;
    }
    cancel() {
        IDisposable.checkDisposed(this);
        if (!this._state) {
            this.resetCore();
            return true;
        }
        return false;
    }
    /**
     * Reset current deferred into idle state and rejecting any pending promise
     * > To avoid rejecting pending promise, use cancel
     * @param force Reset current promise and get a new one even if its not completed
     */
    reset(force) {
        IDisposable.checkDisposed(this);
        if (force) {
            if (!this._state && this._rejectCallback) {
                const err = new DeferredError("Operation cancelled");
                this._rejectCallback(err);
            }
            this.resetCore();
        }
        else if (this._state) {
            this.resetCore();
        }
    }
    resetCore() {
        this._version++;
        this._state = 0;
        delete this._promiseOrResult;
        delete this._resolveCallback;
        delete this._rejectCallback;
    }
    async then(onfulfilled, onrejected) {
        if (this._promiseOrResult instanceof Promise) {
            return this._promiseOrResult.then(onfulfilled, onrejected);
        }
        if (this._state & 4 /* DeferredState.succeed */) {
            if (onfulfilled)
                return onfulfilled(this._promiseOrResult);
        }
        if (this._state & 2 /* DeferredState.faulted */) {
            if (onrejected)
                return onrejected(this._promiseOrResult);
        }
        return this.initAwaiter().then(onfulfilled, onrejected);
    }
    async catch(onrejected) {
        try {
            return await this;
        }
        catch (err) {
            return await onrejected(err);
        }
    }
    async finally(onfinally) {
        try {
            return await this;
        }
        finally {
            onfinally();
        }
    }
    /**
     * Transform current instance into a native promise
     * > This method should be used carefully
     */
    getAwaiter() {
        if (this._promiseOrResult instanceof Promise) {
            return this._promiseOrResult;
        }
        if (this._state & 4 /* DeferredState.succeed */) {
            return Promise.resolve(this._promiseOrResult);
        }
        if (this._state & 2 /* DeferredState.faulted */) {
            return Promise.reject(this._promiseOrResult);
        }
        return this.initAwaiter();
    }
    initAwaiter() {
        const promise = new Promise((resolve, reject) => {
            this._resolveCallback = resolve;
            this._rejectCallback = reject;
        });
        this._promiseOrResult = promise;
        return promise;
    }
    [IDisposable.dispose]() {
        if (this._state !== 8 /* DeferredState.disposed */) {
            this.reject(new DisposedError());
            delete this._promiseOrResult;
            this._state = 8 /* DeferredState.disposed */;
        }
    }
    static resolve(value) {
        const d = new Deferred();
        d.resolve(value);
        return d;
    }
    static reject(reason) {
        const d = new Deferred();
        d.reject(reason);
        return d;
    }
}const NoValue = Symbol();
const Disposed = Symbol();
class Delayed {
    constructor() {
        this._value = NoValue;
    }
    get disposed() { return this._value === Disposed; }
    has() {
        IDisposable.checkDisposed(this);
        return this._value !== NoValue;
    }
    get() {
        IDisposable.checkDisposed(this);
        if (this._value !== NoValue)
            return this._value;
        if (!this._deferred)
            this._deferred = new Deferred();
        return this._deferred;
    }
    set(value) {
        var _a;
        IDisposable.checkDisposed(this);
        this._value = value;
        (_a = this._deferred) === null || _a === void 0 ? void 0 : _a.resolve(value);
    }
    reset() {
        IDisposable.checkDisposed(this);
        IDisposable.safeDispose(this._deferred);
        IDisposable.safeDispose(this._value);
        this._value = NoValue;
    }
    [IDisposable.dispose]() {
        IDisposable.safeDispose(this._deferred);
        IDisposable.safeDispose(this._value);
        this._value = Disposed;
    }
}class TimeoutSource {
    constructor() {
        this._timer = -1;
    }
    get hasPendingCall() { return this._timer !== -1; }
    /** Invoke the pending call and cancel any pending ones */
    invoke(callback, timeout) {
        this.clear();
        this.invokeCore(callback, timeout);
    }
    /** Invoke the provided callback if there is no pending call */
    tryInvoke(callback, timeout) {
        if (this._timer === -1) {
            this.invokeCore(callback, timeout);
            return true;
        }
        return false;
    }
    invokeCore(callback, timeout) {
        this._timer = self.setTimeout(() => {
            this._timer = -1;
            callback();
        }, timeout);
    }
    /** Cancel any pending calls */
    clear() {
        if (this._timer !== -1) {
            clearTimeout(this._timer);
            this._timer = -1;
        }
    }
    [IDisposable.dispose]() {
        this.clear();
    }
}const NO_VALUE = Symbol();
class AbortError extends Error {
}
var AbortToken;
(function (AbortToken) {
    AbortToken.none = Object.freeze({
        aborted: false,
        reason: null,
        signal: null,
        register: () => { },
        throwIfAborted: () => { }
    });
    /**
     * Create a new AbortableToken
     */
    function create(parent) {
        const token = new AbortableToken();
        if (parent)
            token.attach(parent);
        return token;
    }
    AbortToken.create = create;
    /**
     * Return whether or not the provided value is a valid token
     * @param token Token to validate
     */
    function isValidToken(token) {
        return token instanceof ReadOnlyAbortToken
            || token instanceof AbortableToken
            || token === AbortToken.none;
    }
    AbortToken.isValidToken = isValidToken;
})(AbortToken || (AbortToken = {}));
class ReadOnlyAbortToken {
    get aborted() { return this._source.aborted; }
    get reason() { return this._source.reason; }
    get signal() { return this._source.signal; }
    constructor(_source) {
        this._source = _source;
    }
    register(listener) {
        this._source.register(listener);
    }
    throwIfAborted() {
        this._source.throwIfAborted();
    }
}
class AbortableToken extends DisposableHost {
    constructor() {
        super(...arguments);
        this._listeners = [];
        this._controller = new AbortController();
        this._abortReason = NO_VALUE;
    }
    get aborted() { return this._abortReason !== NO_VALUE; }
    get reason() { return this._abortReason !== NO_VALUE ? this._abortReason : null; }
    /** Gets a ReadOnly token that will not be able to abort him by itself */
    get readOnly() {
        if (!this._readOnly) {
            this.checkIfDisposed();
            this._readOnly = new ReadOnlyAbortToken(this);
        }
        return this._readOnly;
    }
    get signal() {
        if (!this._controller) {
            this._controller = new AbortController();
        }
        return this._controller.signal;
    }
    register(listener) {
        this.checkIfDisposed();
        if (listener !== AbortToken.none) {
            this._listeners.push(listener);
        }
    }
    throwIfAborted() {
        this.checkIfDisposed();
        if (this.aborted)
            throw new AbortError();
    }
    abort(reason) {
        var _a;
        if (!this.disposed && !this.aborted) {
            this._abortReason = reason;
            (_a = this._controller) === null || _a === void 0 ? void 0 : _a.abort();
            this._listeners.forEach(async (l) => {
                if (l instanceof Deferred) {
                    l.reject(reason);
                }
                else if (l instanceof Function) {
                    l(reason);
                }
                else {
                    l.abort(reason);
                }
            });
            return true;
        }
        return false;
    }
    /**
     * Attach the promise to abort current token if the promise itself is aborted too
     * @param promiseOrDeferred Promise of Deferred to listen
     */
    attach(abortable) {
        this.checkIfDisposed();
        if (abortable instanceof Promise || abortable instanceof Deferred) {
            abortable.then(null, err => this.abort(err));
        }
        else {
            abortable.register(reason => this.abort(reason));
        }
    }
    dispose() {
        if (this._listeners.length) {
            var reason = new DisposedError("Token disposed");
            this.abort(reason);
            this._listeners.splice(0);
        }
    }
}/**
 * Assert the Promise.allSettled result to ensure all promises are fulfilled results
 * @param results Results to validate
 */
function assertAllSettledResult(results) {
    const rejectedResults = results.filter(isRejectedResult);
    if (rejectedResults.length)
        throw new AllSettledPromiseError(rejectedResults);
}
function isRejectedResult(result) {
    return result.status === "rejected";
}
class AllSettledPromiseError extends AssertionError {
    constructor(rejectedResults) {
        super(`${rejectedResults.length} errors has been trigger during promise settlement`);
        this.rejectedResults = rejectedResults;
    }
}function* resolvePathSegments(target) {
    let current = target;
    while (current) {
        yield current.name;
        current = current.parent;
    }
}
class IoCContainer extends DisposableHost {
    get path() { return [...resolvePathSegments(this)].reverse().join("/"); }
    get abortToken() { var _a, _b; return (_b = (_a = this._token) === null || _a === void 0 ? void 0 : _a.readOnly) !== null && _b !== void 0 ? _b : AbortToken.none; }
    get running() { return this._token ? !this._token.aborted : false; }
    get services() { return this._provider; }
    get ready() { return this._ready; }
    constructor(name, _provider, setups) {
        super();
        this.name = name;
        this._provider = _provider;
        this._children = new Map();
        this._ready = new Deferred();
        this._setups = [...setups];
    }
    createChildScope(name) {
        if (this._children.has(name))
            throw new Error(`Duplicate child scope "${name}"`);
        const delayed = new Delayed();
        this._children.set(name, delayed);
        return this.createIoCModuleBuilder(name, delayed);
    }
    async start() {
        if (this._token)
            return false;
        const token = AbortToken.create();
        this._token = token;
        const setups = this._setups.splice(0);
        try {
            const asyncTasks = [];
            for (const setup of setups) {
                token.throwIfAborted();
                const task = setup.exec(this._provider, token);
                if (setup.execBehavior === IoCModuleSetupExecBehavior.asynchronous) {
                    asyncTasks.push(task);
                }
                else {
                    const taskResult = await task;
                    if (taskResult === IoCModuleSetupResultBehavior.stop)
                        break;
                }
            }
            if (asyncTasks.length !== 0) {
                const results = await Promise.allSettled(asyncTasks);
                assertAllSettledResult(results);
            }
            this._ready.resolve(this);
            return true;
        }
        catch (err) {
            token.abort(err);
            this._ready.reject(err);
            return false;
        }
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            for (const child of this._children.values()) {
                yield yield __await(yield __await(child.get()));
            }
        });
    }
    dispose() {
        IDisposable.safeDisposeAll(this._children.values());
        IDisposable.safeDispose(this._provider);
        IDisposable.safeDispose(this._token);
    }
}
__decorate([
    Memoize
], IoCContainer.prototype, "path", null);class IoCModuleBuilder extends IoCContainerBuilder {
    constructor(name, _result, _parent, _factory) {
        super(name);
        this._result = _result;
        this._parent = _parent;
        this._factory = _factory;
    }
    createModule(name, provider, setups) {
        const result = this._factory(name, provider, setups, this._parent);
        this._result.set(result);
        return result;
    }
    createServiceProvider(services) {
        return new ServiceProvider(services, this._parent.services);
    }
}class IoCModule extends IoCContainer {
    get parent() { return this._parent; }
    constructor(name, provider, setupCallbacks, _parent) {
        super(name, provider, setupCallbacks);
        this._parent = _parent;
    }
    createIoCModuleBuilder(name, target) {
        return new IoCModuleBuilder(name, target, this, IoCModule.factory);
    }
    static factory(name, provider, setupCallbacks, parent) {
        return new IoCModule(name, provider, setupCallbacks, parent);
    }
}class IoCKernel extends IoCContainer {
    createIoCModuleBuilder(name, target) {
        return new IoCModuleBuilder(name, target, this, IoCModule.factory);
    }
    static create() {
        return new IoCKernelBuilder("root");
    }
}
class IoCKernelBuilder extends IoCContainerBuilder {
    createModule(name, provider, setups) {
        return new IoCKernel(name, provider, setups);
    }
    createServiceProvider(services) {
        return new ServiceProvider(services);
    }
    configureDefaultServices(services, _provider) {
        services.addTransient(ServiceAccessor);
    }
}const IClock = ServiceIdentifier("IClock");
let SystemClock = class SystemClock {
    now() {
        return new Date();
    }
    utcNow() {
        return new Date(Date.now());
    }
};
SystemClock = __decorate([
    ServiceContract(IClock)
], SystemClock);const IConfiguration = ServiceIdentifier("IConfiguration");
let Configuration = class Configuration extends DisposableHost {
    get values() { return this._config; }
    get onDidUpdated() { return this._onDidUpdated.event; }
    constructor(config) {
        super();
        this._config = structuredClone(config);
        this.registerForDispose(this._onDidUpdated = new EventEmitter());
    }
    update(config) {
        for (const [key, value] of Object.entries(config)) {
            Object.assign(this._config, { [key]: structuredClone(config) });
            this._onDidUpdated.emit(key, value);
        }
    }
};
Configuration = __decorate([
    ServiceContract(IConfiguration)
], Configuration);const ILogger = ServiceIdentifier("ILogger");
const ILoggerSink = ServiceIdentifier("ILoggerSink");
let DefaultLogger = class DefaultLogger {
    constructor(_iocModule, _clock, _sinks) {
        this._iocModule = _iocModule;
        this._clock = _clock;
        this._sinks = _sinks;
    }
    log(logLevel, err, templateMessage, ...params) {
        const properties = {};
        const message = templateMessage.replaceAll(/\{([\w]+)\}/gi, (original, key) => {
            if (properties.hasOwnProperty(key)) {
                return properties[key];
            }
            if (params.length !== 0) {
                const result = params.shift();
                properties[key] = result;
                return result;
            }
            return original;
        });
        properties["extraValues"] = params;
        const event = {
            scope: this._iocModule.path,
            time: this._clock.utcNow(),
            logLevel,
            message,
            properties,
            err
        };
        for (const sink of this._sinks)
            sink.log(event);
    }
    trace(templateMessage, ...params) {
        this.log(0 /* LogLevel.trace */, null, templateMessage, ...params);
    }
    debug(templateMessage, ...params) {
        this.log(1 /* LogLevel.debug */, null, templateMessage, ...params);
    }
    info(templateMessage, ...params) {
        this.log(2 /* LogLevel.info */, null, templateMessage, ...params);
    }
    warn(err, templateMessage, ...params) {
        this.log(3 /* LogLevel.warn */, err, templateMessage, ...params);
    }
    error(err, templateMessage, ...params) {
        this.log(4 /* LogLevel.error */, err, templateMessage, ...params);
    }
    critical(err, templateMessage, ...params) {
        this.log(5 /* LogLevel.critical */, err, templateMessage, ...params);
    }
};
DefaultLogger = __decorate([
    ServiceContract(ILogger),
    __param(0, IIoCModule),
    __param(1, IClock),
    __param(2, Many(ILoggerSink))
], DefaultLogger);
const DateFormat = new Intl.DateTimeFormat("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hourCycle: "h24",
    fractionalSecondDigits: 3
});
let ConsoleLoggerSink = class ConsoleLoggerSink {
    constructor(_level) {
        this._level = _level;
    }
    log({ scope, time, logLevel, message, err, properties }) {
        if (this.isEnabled(logLevel)) {
            const formatedTime = DateFormat.format(time);
            const log = `[${formatedTime}] [${scope}] ${message}`;
            const args = [log, properties];
            if (err)
                args.push(err);
            switch (logLevel) {
                case 0 /* LogLevel.trace */:
                    console.trace(...args);
                    break;
                case 1 /* LogLevel.debug */:
                    console.debug(...args);
                    break;
                case 2 /* LogLevel.info */:
                    console.info(...args);
                    break;
                case 3 /* LogLevel.warn */:
                    console.warn(...args);
                    break;
                case 4 /* LogLevel.error */:
                case 5 /* LogLevel.critical */:
                    console.error(...args);
                    break;
                default:
                    console.log(message);
                    break;
            }
        }
    }
    isEnabled(logLevel) {
        return logLevel >= this._level;
    }
};
ConsoleLoggerSink = __decorate([
    ServiceContract(ILoggerSink)
], ConsoleLoggerSink);function addConsoleLogger(level) {
    return this
        .addSystemClock()
        .addSingleton(ConsoleLoggerSink, { baseArgs: [level] })
        .tryAddScoped(DefaultLogger);
}
function addSystemClock() {
    return this.tryAddSingleton(SystemClock);
}
function addConfiguration(config) {
    return this.addSingleton(Configuration, { baseArgs: [config] });
}
Object.assign(ServiceCollection.prototype, {
    addConsoleLogger, addSystemClock, addConfiguration
});const IApplicationPart = ServiceIdentifier("IApplicationPart");const configure = Symbol("configure");
var IAppConfigureHandler;
(function (IAppConfigureHandler) {
    function create(callback) {
        class CallbackAppConfigureHandler extends CallbackConfigureHandler {
            constructor() {
                super(callback);
            }
        }
        return CallbackAppConfigureHandler;
    }
    IAppConfigureHandler.create = create;
})(IAppConfigureHandler || (IAppConfigureHandler = {}));
class CallbackConfigureHandler {
    constructor(_callback) {
        this._callback = _callback;
    }
    [configure](builder, host) {
        this._callback(builder, host);
    }
}class SetupIoCContainerBuilder {
    constructor(_appBuilder, _iocBuilder) {
        this._appBuilder = _appBuilder;
        this._iocBuilder = _iocBuilder;
    }
    continueWithoutAwaiting() {
        this._iocBuilder.continueWithoutAwaiting();
        return this._appBuilder;
    }
    catch(errorHandler) {
        this._iocBuilder.catch(errorHandler);
        return this._appBuilder;
    }
    use(action) {
        return this._appBuilder.use(action);
    }
    addPart(path, configHandler) {
        return this._appBuilder.addPart(path, configHandler);
    }
    addAction(path, actionOrServiceId, action) {
        return this._appBuilder.addAction(path, actionOrServiceId, action);
    }
    setup(serviceIdOrCtor, action, required = true) {
        return this._appBuilder.setup(serviceIdOrCtor, action, required);
    }
    setupMany(serviceIdOrCtor, action, currentScopeOnly = true) {
        return this._appBuilder.setupMany(serviceIdOrCtor, action, currentScopeOnly);
    }
    configure(action) {
        return this._appBuilder.configure(action);
    }
    build() {
        return this._appBuilder.build();
    }
}const INavigationHandler = ServiceIdentifier("INavigationHandler");const IRouter = ServiceIdentifier("IRouter");let DefaultNavigationHandler = class DefaultNavigationHandler {
    constructor(_router) {
        this._router = _router;
    }
    start() {
        this._router.eval(location.href);
    }
    stop() { }
};
DefaultNavigationHandler = __decorate([
    ServiceContract(INavigationHandler),
    __param(0, IRouter)
], DefaultNavigationHandler);function on(target, type, callback, options) {
    target.addEventListener(type, callback, options);
    return IDisposable.create(() => {
        target.removeEventListener(type, callback, options);
    });
}let HistoryNavigationHandler = class HistoryNavigationHandler {
    constructor(_router) {
        this._router = _router;
    }
    start() {
        this._popstateHandle = on(window, "popstate", this.onNavigate);
    }
    onNavigate(ev) {
        this._router.eval(location.href, ev.state);
    }
    stop() {
        IDisposable.safeDispose(this._popstateHandle);
    }
    [Symbol.dispose]() {
        this.stop();
    }
};
HistoryNavigationHandler = __decorate([
    ServiceContract(INavigationHandler),
    __param(0, IRouter)
], HistoryNavigationHandler);let HyperlinkNavigationHandler = class HyperlinkNavigationHandler {
    constructor(_router) {
        this._router = _router;
    }
    start() {
        if (this._registration)
            return;
        this._registration = on(document.body, "click", ev => this.onRootClick(ev));
    }
    onRootClick(ev) {
        const anchor = this.findAnchor(ev);
        if (!anchor)
            return;
        const url = new URL(anchor.href, location.href);
        if (location.origin !== url.origin)
            return;
        ev.preventDefault();
        ev.stopPropagation();
        if (location.href === url.href)
            return;
        const result = this._router.eval(url.pathname);
        if (result) {
            history.pushState({}, anchor.innerText, url);
        }
        else {
            location.assign(url);
        }
    }
    findAnchor(ev) {
        for (const item of ev.composedPath()) {
            if (item instanceof HTMLAnchorElement)
                return item;
        }
    }
    stop() {
        IDisposable.safeDispose(this._registration);
        this._registration;
    }
    [Symbol.dispose]() {
        this.stop();
    }
};
HyperlinkNavigationHandler = __decorate([
    ServiceContract(INavigationHandler),
    __param(0, IRouter)
], HyperlinkNavigationHandler);const SEGMENT_SEPARATOR$1 = "/";
const WILDCARD_CHAR = "*";
const ASSIGN_CHAR = ":";
const NULLABLE_CHAR = "?";
const RELATIVE_CHAR = "~";function shiftOrThrow(ctx, value) {
    const current = ctx.getAt(0);
    if (current !== value) {
        throw new Error(`Invalid token: expected segment equal to "${value}" but current segment is equal to "${current}"`);
    }
    ctx.shift();
}
class StaticRouteSegment {
    get segment() { return this._segment; }
    constructor(_segment) {
        this._segment = _segment;
    }
    match(segment) {
        return segment === this._segment;
    }
    read(ctx, values) {
        shiftOrThrow(ctx, this._segment);
    }
}
class WildcardRouteSegment {
    constructor() { }
    match(segment) { return true; }
    read(ctx, values) {
        shiftOrThrow(ctx, WILDCARD_CHAR);
    }
}
WildcardRouteSegment.instance = new WildcardRouteSegment();
class RelativeRouteSegment {
    constructor() { }
    match(segment) { return true; }
    read(ctx, values) {
        shiftOrThrow(ctx, RELATIVE_CHAR);
    }
}
RelativeRouteSegment.instance = new RelativeRouteSegment();
class StringRouteSegment {
    get name() { return this._name; }
    get optional() { return this._optional; }
    get defaultValue() { return this._defaultValue; }
    constructor(_name, _optional, _defaultValue) {
        this._name = _name;
        this._optional = _optional;
        this._defaultValue = _defaultValue;
    }
    match(segment) {
        if (typeof segment === "undefined") {
            return this._optional;
        }
        return true;
    }
    read(ctx, values) {
        var _a;
        const value = (_a = ctx.shift()) !== null && _a !== void 0 ? _a : this._defaultValue;
        if (typeof value !== "undefined") {
            this.loadValue(this._name, value, values);
        }
    }
    loadValue(name, value, values) {
        values[name] = value;
    }
}
class EnumRouteSegment extends StringRouteSegment {
    constructor(name, _enums, optional, defaultValue) {
        super(name, optional, defaultValue);
        this._enums = _enums;
    }
    match(segment) {
        if (typeof segment === "undefined") {
            return this.optional;
        }
        return this._enums.indexOf(segment) !== -1;
    }
}
class NumberRouteSegment extends StringRouteSegment {
    match(segment) {
        if (typeof segment === "undefined") {
            return this.optional;
        }
        return !isNaN(+segment);
    }
    loadValue(name, value, values) {
        values[name] = +value;
    }
}/** */
class Route {
    get wildcard() { var _a; return (_a = this._wildcard) !== null && _a !== void 0 ? _a : false; }
    get relative() { var _a; return (_a = this._relative) !== null && _a !== void 0 ? _a : false; }
    constructor(segments) {
        const array = [...segments];
        if (array[array.length - 1] === WildcardRouteSegment.instance) {
            array.pop();
            this._wildcard = true;
        }
        if (array[0] === RelativeRouteSegment.instance) {
            array.shift();
            this._relative = true;
        }
        this._segments = array;
    }
    match(ctx) {
        if (!this._wildcard && ctx.remaining > this._segments.length)
            return false;
        if (this._relative && ctx.remaining === ctx.initialSize)
            return false;
        for (let idx = 0; idx < this._segments.length; idx++) {
            const value = ctx.getAt(idx);
            if (!this._segments[idx].match(value)) {
                return false;
            }
        }
        return true;
    }
    getRouteValues(ctx) {
        const values = {};
        for (let i = 0; i < this._segments.length; i++) {
            this._segments[i].read(ctx, values);
        }
        return values;
    }
    *[Symbol.iterator]() {
        yield* this._segments;
    }
    static parse(route) {
        const segments = Route.parseRoute(route);
        return new Route(segments);
    }
    static *parseRoute(route) {
        const segments = route.split(SEGMENT_SEPARATOR$1).filter(Boolean);
        if (segments[0] === RELATIVE_CHAR) {
            segments.shift();
            yield RelativeRouteSegment.instance;
        }
        for (let segment of segments) {
            if (segment === WILDCARD_CHAR) {
                yield WildcardRouteSegment.instance;
                break;
            }
            if (segment.startsWith(ASSIGN_CHAR)) {
                segment = segment.substring(1);
                // 2 segments when ever their is "?": ""
                const params = segment.split(NULLABLE_CHAR);
                if (params.length === 2) {
                    yield this.createDynamicSegment(params[0], true, params[1]);
                }
                else {
                    yield this.createDynamicSegment(segment, false);
                }
            }
            else {
                yield new StaticRouteSegment(segment);
            }
        }
    }
    // url/:value<enum|enum|enum>
    static createDynamicSegment(name, optional, defaultValue) {
        if (name.startsWith("+")) {
            return new NumberRouteSegment(name.substring(1), optional, defaultValue);
        }
        const idx = name.indexOf("<");
        if (idx !== -1 && name.endsWith(">")) {
            const values = name.substring(idx + 1, name.length - 2).split("|");
            name = name.substring(0, idx);
            return new EnumRouteSegment(name, values, optional, defaultValue);
        }
        return new StringRouteSegment(name, optional, defaultValue);
    }
}const IRoutingHandler = ServiceIdentifier("IRoutingHandler");let ActionRoutingHandler = class ActionRoutingHandler {
    get path() { return this._path; }
    get route() { return this._route; }
    constructor(_path, _action) {
        this._path = _path;
        this._action = _action;
        this._route = Route.parse(_path);
    }
    handle(data, app) {
        const result = this._action({ data, app, route: this.route });
        if (result instanceof Promise)
            return result;
        return Promise.resolve();
    }
};
ActionRoutingHandler = __decorate([
    ServiceContract(IRoutingHandler)
], ActionRoutingHandler);let ServiceRoutingHandler = class ServiceRoutingHandler {
    get path() { return this._path; }
    get route() { return this._route; }
    constructor(_path, _serviceId, _action) {
        this._path = _path;
        this._serviceId = _serviceId;
        this._action = _action;
        this._route = Route.parse(_path);
    }
    handle(data, app) {
        const service = app.services.get(this._serviceId, true);
        const result = this._action(service, data);
        if (result instanceof Promise)
            return result;
        return Promise.resolve();
    }
};
ServiceRoutingHandler = __decorate([
    ServiceContract(IRoutingHandler)
], ServiceRoutingHandler);class RouteResolutionContext {
    get remaining() { return this._segments.length; }
    get initialSize() { return this._initialSize; }
    constructor(segments) {
        this._segments = [...segments];
        this._initialSize = this._segments.length;
    }
    getAt(index) {
        return this._segments[index];
    }
    peek() {
        return this._segments[0];
    }
    shift() {
        return this._segments.shift();
    }
    *[Symbol.iterator]() {
        yield* this._segments;
    }
    toString() {
        return this._segments.join("/");
    }
}const SEGMENT_SEPARATOR = "/";
let DefaultRouter = class DefaultRouter {
    constructor(_handlers, _application, _logger) {
        this._handlers = _handlers;
        this._application = _application;
        this._logger = _logger;
    }
    eval(url, defaults = {}) {
        const parsedUrl = new URL(url, location.origin);
        let path = parsedUrl.pathname;
        if (path.startsWith(SEGMENT_SEPARATOR))
            path = path.substring(1);
        if (path.endsWith(SEGMENT_SEPARATOR))
            path = path.substring(0, path.length - 1);
        const segments = path.split(SEGMENT_SEPARATOR);
        const ctx = new RouteResolutionContext(segments);
        const search = new URLSearchParams(parsedUrl.search);
        const query = Object.fromEntries(search);
        return this.handle(ctx, defaults, query);
    }
    handle(ctx, values, query) {
        const handler = this._handlers.find(x => x.route.match(ctx));
        if (!handler) {
            const handlerPaths = this._handlers.map(x => x.path);
            this._logger.warn(`No match found for the remaining route path: {relativeUrl}`, ctx.toString(), ...handlerPaths);
            return false;
        }
        return this.invokeHandler(handler, ctx, values, query);
    }
    async invokeHandler(handler, ctx, values, query) {
        var _a, e_1, _b, _c;
        const relativeUrl = ctx.toString();
        const localValues = handler.route.getRouteValues(ctx);
        const mergedValues = Object.assign({}, values, localValues);
        const routeData = { values: mergedValues, query };
        this._logger.info(`Routing match url "{relativeUrl}" with route "{routePath}"`, relativeUrl, handler.path, routeData);
        try {
            await handler.handle(routeData, this._application);
        }
        catch (err) {
            this._logger.log(4 /* LogLevel.error */, err, "Error handled during route handler invocation");
        }
        if (ctx.remaining === 0)
            return;
        try {
            for (var _d = true, _e = __asyncValues(this._application), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const childApp = _c;
                const router = childApp.services.get(IRouter);
                if (!router)
                    continue;
                const evalResult = router.handle(ctx, values, query);
                if (evalResult === false)
                    continue;
                await evalResult;
                break;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
};
DefaultRouter = __decorate([
    ServiceContract(IRouter),
    __param(0, Many(IRoutingHandler)),
    __param(1, IApplicationPart),
    __param(2, ILogger)
], DefaultRouter);let PartLoaderRoutingHandler = class PartLoaderRoutingHandler {
    get path() { return this._path; }
    get route() { return this._route; }
    constructor(_path, _configHandler) {
        this._path = _path;
        this._configHandler = _configHandler;
        this._route = Route.parse(_path);
    }
    async handle(data, app) {
        const appName = data.values["app"];
        if (typeof appName !== "string")
            throw new Error(`Missing route value named 'app'`);
        await app.load(appName, this._configHandler);
    }
};
PartLoaderRoutingHandler = __decorate([
    ServiceContract(IRoutingHandler)
], PartLoaderRoutingHandler);class ApplicationPartBuilder {
    constructor(partName, _source, _result) {
        this._source = _source;
        this._result = _result;
        this._innerBuilder = _source.createChildScope(partName);
        this.initDefaults();
    }
    initDefaults() {
        this.setupMany(INavigationHandler, x => x.start());
    }
    addPart(path, configHandler) {
        const ctor = this.resolveConfigHandler(configHandler);
        this.configure(x => x.addScoped(PartLoaderRoutingHandler, {
            baseArgs: [path, ctor],
            scope: 1 /* ServiceScope.container */
        }));
        return this;
    }
    resolveConfigHandler(configHandler) {
        if (configure in configHandler) {
            return configHandler;
        }
        return IAppConfigureHandler.create(configHandler);
    }
    addAction(path, actionOrServiceId, action) {
        if (ServiceIdentifier.is(actionOrServiceId)) {
            this.configure(x => x.addScoped(ServiceRoutingHandler, {
                baseArgs: [path, actionOrServiceId, action],
                scope: 1 /* ServiceScope.container */
            }));
        }
        else {
            this.configure(x => x.addScoped(ActionRoutingHandler, {
                baseArgs: [path, actionOrServiceId],
                scope: 1 /* ServiceScope.container */
            }));
        }
        return this;
    }
    configure(action) {
        this._innerBuilder.configure(action);
        return this;
    }
    use(action) {
        const iocBuilder = this._innerBuilder.use(action);
        return new SetupIoCContainerBuilder(this, iocBuilder);
    }
    setupMany(ctor, action, currentScopeOnly) {
        const iocBuilder = this._innerBuilder.setupMany(ctor, action, currentScopeOnly);
        return new SetupIoCContainerBuilder(this, iocBuilder);
    }
    setup(ctor, action, required) {
        const iocBuilder = this._innerBuilder.setup(ctor, action, required);
        return new SetupIoCContainerBuilder(this, iocBuilder);
    }
    build() {
        const part = this.createApplicationPart(this._source, this._innerBuilder);
        this._result.set(part);
        return part;
    }
}const IApplicationPartLifecycle = ServiceIdentifier("IApplicationPartLifecycle");
/** Symbol used to identify a method called during setup */
const setup = Symbol("setup");
/** Symbol used to identify a method when the part is activated */
const activated = Symbol("activated");
/** Symbol used to identify a method when the part is put in background */
const deactivated = Symbol("deactivated");class ApplicationPart extends DisposableHost {
    get name() { return this._module.name; }
    get path() { return this._module.path; }
    get running() { return this._module.running; }
    get activeChild() { return this._current; }
    get ready() { return this._module.ready.then(() => this); }
    get abortToken() { return this._module.abortToken; }
    get services() { return this._module.services; }
    constructor(builder) {
        super();
        this._children = new Map();
        this._module = builder
            .configure(x => x.addInstance(IApplicationPart, this, { scope: 1 /* ServiceScope.container */ }))
            .setupMany(IApplicationPartLifecycle, x => x[setup](), true)
            .build();
    }
    getChild(name) {
        return this._children.get(name);
    }
    async addChild(delayedChild) {
        const child = await delayedChild.get();
        const current = this._children.get(child.name);
        IDisposable.safeDispose(current);
        this._children.set(child.name, child);
        if (child instanceof DisposableHost) {
            child.registerForDispose(IDisposable.create(() => {
                const current = this._children.get(child.name);
                if (current === child)
                    this._children.delete(child.name);
            }));
        }
    }
    start() { return this._module.start(); }
    async load(name, handlerCtor) {
        this.throwIfExists(name);
        const builder = this.createAppBuilder(name);
        const handler = this.services.createInstance(handlerCtor);
        handler[configure](builder, this);
        const part = builder.build();
        await part.start();
        await this.activate(name);
        return part;
    }
    activate(name) {
        const part = this._children.get(name);
        if (part)
            return this.activatePart(part);
        throw new Error(`Cannot find any module named ${name}`);
    }
    async activatePart(part) {
        if (this._current)
            await this.invokeLifecycle(this._current, deactivated);
        await this.invokeLifecycle(part, activated);
    }
    async invokeLifecycle(part, method) {
        const promises = [];
        for (const svc of part.services.getAll(IApplicationPartLifecycle, true)) {
            const result = svc[method]();
            promises.push(result);
        }
        const allSettledResult = await Promise.allSettled(promises);
        assertAllSettledResult(allSettledResult);
    }
    createChildScope(name) {
        this.throwIfExists(name);
        return this._module.createChildScope(name);
    }
    throwIfExists(name) {
        const current = this._children.get(name);
        if (current)
            throw new Error(`An application part with the same name already exists`);
    }
    [Symbol.dispose]() {
        IDisposable.safeDispose(this._module);
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            yield __await(yield* __asyncDelegator(__asyncValues(this._children.values())));
        });
    }
}
__decorate([
    Memoize
], ApplicationPart.prototype, "ready", null);class DefaultApplicationConfigureHandler {
    [configure](builder, host) {
        builder.configure(x => {
            x.addSingleton(DefaultNavigationHandler, { scope: 1 /* ServiceScope.container */ })
                .addSingleton(HistoryNavigationHandler, { scope: 1 /* ServiceScope.container */ })
                .addSingleton(HyperlinkNavigationHandler, { scope: 1 /* ServiceScope.container */ })
                .addScoped(DefaultRouter);
        });
    }
}class ChildApplicationPartBuilder extends ApplicationPartBuilder {
    constructor(partName, source, result) {
        super(partName, source, result);
    }
    createApplicationPart(parent, iocBuilder) {
        return new ChildApplicationPart(parent, iocBuilder);
    }
}
class ChildApplicationPart extends ApplicationPart {
    get parent() { return this._parent; }
    constructor(_parent, builder) {
        super(builder);
        this._parent = _parent;
    }
    createAppBuilder(name) {
        const result = new Delayed();
        this.addChild(result);
        return new ChildApplicationPartBuilder(name, this, result);
    }
}class SinglePageAppBuilder extends ApplicationPartBuilder {
    createApplicationPart(parent, iocBuilder) {
        return new SinglePageApplication(parent, iocBuilder);
    }
}
class SinglePageApplication extends ApplicationPart {
    get parent() { return this._parent; }
    constructor(_parent, builder) {
        super(builder);
        this._parent = _parent;
    }
    createAppBuilder(name) {
        const result = new Delayed();
        this.addChild(result);
        return new ChildApplicationPartBuilder(name, this, result);
    }
    static createKernel() {
        const builder = IoCKernel.create();
        builder.configure(x => {
            x.addConsoleLogger(0 /* LogLevel.trace */);
        });
        return builder.build();
    }
    async start() {
        return await this._parent.start() && await super.start();
    }
    static create(appName, ...handlerCtors) {
        const kernel = SinglePageApplication.createKernel();
        const result = new Delayed();
        const builder = new SinglePageAppBuilder(appName, kernel, result);
        for (const handlerCtor of handlerCtors) {
            const handler = kernel.services.createInstance(handlerCtor);
            handler[configure](builder);
        }
        return builder;
    }
    static async start(appName, configure) {
        const handler = IAppConfigureHandler.create(configure);
        const app = SinglePageApplication.create(appName, DefaultApplicationConfigureHandler, handler).build();
        await app.start();
        asserts.instanceOf(app, SinglePageApplication);
        return app;
    }
}const IRendererService = ServiceIdentifier("IRendererService");
let DefaultRendererService = class DefaultRendererService {
    render(data) {
        const actual = document.body.querySelector("#default-renderer-output");
        if (actual)
            actual.remove();
        const div = document.createElement("div");
        div.innerText = data;
        div.id = "default-renderer-output";
        document.body.appendChild(div);
    }
};
DefaultRendererService = __decorate([
    ServiceContract(IRendererService)
], DefaultRendererService);SinglePageApplication.start("Library", (builder) => {
    builder.configure(x => x.addSingleton(DefaultRendererService));
    builder.addAction("/:view/*", IRendererService, (renderer, data) => renderer.render(`Selected view: ${data.values["view"]}`));
});//# sourceMappingURL=demo.min.js.map
