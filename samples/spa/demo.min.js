class AssertionError extends Error {
}
var asserts;
(function (asserts) {
    function defined(value, message) {
        if (typeof value === "undefined") {
            throw new AssertionError(message !== null && message !== void 0 ? message : "Value expected to be defined");
        }
    }
    asserts.defined = defined;
    function notDefined(value, message) {
        if (typeof value !== "undefined") {
            throw new AssertionError(message !== null && message !== void 0 ? message : "Value expected to be undefined");
        }
    }
    asserts.notDefined = notDefined;
    function object(value, message) {
        if (typeof value === "object" && value !== null) {
            throw new AssertionError(message !== null && message !== void 0 ? message : "Value expected to be an object");
        }
    }
    asserts.object = object;
    function ensure(value, message) {
        if (typeof value === "undefined" || value === null) {
            throw new AssertionError(message !== null && message !== void 0 ? message : "Value expected to be defined and not null");
        }
    }
    asserts.ensure = ensure;
    function returns(value, message) {
        ensure(value, message);
        return value;
    }
    asserts.returns = returns;
    function ofType(value, type, message) {
        if (typeof value !== type) {
            throw new AssertionError(message !== null && message !== void 0 ? message : `Expected typeof "${type}" but having a typeof "${typeof value}"`);
        }
    }
    asserts.ofType = ofType;
    function instanceOf(value, type, message) {
        if (!(value instanceof type)) {
            throw new AssertionError(message !== null && message !== void 0 ? message : `Expected to be an instance of "${type.name}"`);
        }
    }
    asserts.instanceOf = instanceOf;
    function create(predicate) {
        return (value, message) => {
            if (predicate(value))
                throw new AssertionError(message !== null && message !== void 0 ? message : "Assertion failed");
        };
    }
    asserts.create = create;
})(asserts || (asserts = {}));if (!Symbol.dispose)
    Object.assign(Symbol, { dispose: Symbol("dispose") });
function IDisposable(ctor) {
    class CustomDisposable extends ctor {
    }
    for (const key of Reflect.ownKeys(DisposableHost.prototype)) {
        const desc = Object.assign({}, Reflect.getOwnPropertyDescriptor(DisposableHost.prototype, key));
        Reflect.defineProperty(CustomDisposable.prototype, key, desc);
    }
    return CustomDisposable;
}
(function (IDisposable) {
    /** @deprecated use Symbol.dispose instead */
    IDisposable.dispose = Symbol.dispose;
    /**
     * Create a new IDisposable from a callback
     * @param callback Callback to call when dispose is invoked
     * @returns Returns a new IDiposable instance
     */
    function create(callback) {
        return { [Symbol.dispose]: () => void callback() };
    }
    IDisposable.create = create;
    /**
     * Dispose all provide instances, support any iterable instance.
     * @param instances Instances to dispose
     * @returns Returns all errors encountered during disposing each instances.
     */
    function safeDisposeAll(instances) {
        if (typeof instances === "object" && instances !== null && typeof instances[Symbol.iterator] === "function") {
            return [...instances].map(safeDispose);
        }
        return [];
    }
    IDisposable.safeDisposeAll = safeDisposeAll;
    /**
     * Dispose the provided instance and catch exceptions that may occur
     * @param instance Instance to dispose
     * @returns Returns the catched disposing error or undefined
     */
    function safeDispose(instance) {
        if (typeof instance === "object" && instance !== null && typeof instance[Symbol.dispose] === "function") {
            try {
                instance[Symbol.dispose]();
            }
            catch (ex) {
                return ex;
            }
        }
    }
    IDisposable.safeDispose = safeDispose;
    /**
     * Check if an instance is disposed, throw an error if it is
     * @param instance Instance to check
     */
    function checkDisposed(instance) {
        if (instance.disposed)
            throw new DisposedError("Try to access to a disposed instance");
    }
    IDisposable.checkDisposed = checkDisposed;
})(IDisposable || (IDisposable = {}));
/**
 * Error triggered when trying to use a diposed instance
 */
class DisposedError extends Error {
}
/**
 * Represents a class that contains dependencies to dispose
 */
class DisposableHost {
    get disposed() { return Boolean(this._disposed); }
    /**
     * Register all provided instances to dispose them when current instance will be disposed
     * @param disposables Instance to attach
     */
    registerForDispose(...disposables) {
        if (this._disposables) {
            for (const disposable of disposables) {
                this._disposables.add(disposable);
            }
        }
        else {
            this._disposables = new Set(disposables);
        }
    }
    checkIfDisposed() {
        IDisposable.checkDisposed(this);
    }
    [Symbol.dispose]() {
        if (!this._disposed) {
            this._disposed = true;
            IDisposable.safeDisposeAll(this._disposables);
            delete this._disposables;
            this.dispose && this.dispose();
        }
    }
}const IsLazyProxy = Symbol();
class Lazy {
    get disposed() { return this._state === 4 /* LazyState.disposed */; }
    constructor(_factory, ctor) {
        this._factory = _factory;
        this._prototype = ctor === null || ctor === void 0 ? void 0 : ctor.prototype;
    }
    build() {
        IDisposable.checkDisposed(this);
        if (this._state === 2 /* LazyState.value */)
            return false;
        try {
            const result = this._factory();
            // Avoid keeping references through the factory callback
            // Avoid also any dirty hacked state to throw errors with strong reference to value
            this._factory = () => result;
            this._value = result;
            this._state = 2 /* LazyState.value */;
            if (typeof this._value === "object") {
                this._prototype = Reflect.getPrototypeOf(this._value);
            }
        }
        catch (err) {
            this._value = err;
            this._state = 1 /* LazyState.proxy */;
        }
        return true;
    }
    has() {
        return this._state === 2 /* LazyState.value */;
    }
    get() {
        IDisposable.checkDisposed(this); // LazyState.disposed
        if (this._state === 3 /* LazyState.faulted */)
            throw this._value;
        if (typeof this._state === "undefined") {
            this._value = new Proxy(Object.create(null), this.createProxyHandler());
            this._state = 1 /* LazyState.proxy */;
        }
        // LazyState.proxy &  LazyState.value
        return this._value;
    }
    [Symbol.dispose]() {
        if (this._state === 2 /* LazyState.value */) {
            IDisposable.safeDispose(this._value);
        }
        this._state = 4 /* LazyState.disposed */;
        // Avoid keeping references through the factory callback
        this._factory = () => { throw new DisposedError(); };
    }
    getInstance() {
        this.build(); // CheckDisposed done
        if (this._state === 3 /* LazyState.faulted */)
            throw this._value;
        return this._value;
    }
    createProxyHandler() {
        return {
            get: (_, prop) => {
                if (prop === IsLazyProxy)
                    return true;
                const instance = this.getInstance();
                return Reflect.get(instance, prop, instance);
            },
            set: (_, prop, value) => {
                const instance = this.getInstance();
                return Reflect.set(instance, prop, value, instance);
            },
            deleteProperty: (_, prop) => {
                const instance = this.getInstance();
                return Reflect.deleteProperty(instance, prop);
            },
            getPrototypeOf: (_) => {
                var _a;
                return (_a = this._prototype) !== null && _a !== void 0 ? _a : Object;
            },
            getOwnPropertyDescriptor: (_, prop) => {
                const instance = this.getInstance();
                return Reflect.getOwnPropertyDescriptor(instance, prop);
            },
            ownKeys: (_) => {
                const instance = this.getInstance();
                return Reflect.ownKeys(instance);
            }
        };
    }
    static get(factory, ctor) {
        const lazy = new Lazy(factory, ctor);
        return lazy.get();
    }
}function createReadOnlyTag(description, has, get) {
    const readOnlyTag = Object.assign(target => get(target), {
        get, has,
        toString: () => description
    });
    return Object.freeze(readOnlyTag);
}
/** Create a new Tag */
function Tag(description, defaultValue) {
    const store = new WeakMap();
    const has = (target) => store.has(target);
    const get = (target) => has(target) ? store.get(target) : defaultValue;
    const set = (target, value) => void store.set(target, value);
    const readOnlyTag = createReadOnlyTag(description, has, get);
    return Object.assign((...args) => args.length == 1 ? get(args[0]) : set(args[0], args[1]), readOnlyTag, {
        readOnly: () => readOnlyTag,
        set,
        delete: target => store.delete(target)
    });
}
(function (Tag) {
    function lazy(description, factory, state) {
        const store = new WeakMap();
        const has = (target) => store.has(target);
        const get = (target) => {
            if (!has(target)) {
                store.set(target, factory(target, state));
            }
            return store.get(target);
        };
        return createReadOnlyTag(description, has, get);
    }
    Tag.lazy = lazy;
})(Tag || (Tag = {}));var Tags;
(function (Tags) {
    /**
     * hashId allow to attribute a id to an instance to simplify the creation of hash codes.
     * Using hashId, you can create a hashCode by simply string concat two of these id with a separator.
     *
     * This is very usefull in case of compound keys where the key targets two objects
     * and have to be the key of a Map or a Set.
     *
     * @example
     * // This hash will be unique and can be reproduced
     * `${Tags.hashId.get(obj1)}-${Tags.hashId.get(obj2)}`;
     */
    Tags.hashId = Tag.lazy("hashId", (_, state) => ++state.lastId, { lastId: 0 });
})(Tags || (Tags = {}));class HashMap {
    constructor(hashFactory = k => k, values) {
        this._hashFactory = hashFactory;
        this._store = new Map(this.mapEntries(values));
    }
    get size() { return this._store.size; }
    get [Symbol.toStringTag]() { return "[Object HashMap]"; }
    has(key) {
        const hash = this._hashFactory(key);
        return this._store.has(hash);
    }
    get(key) {
        const entry = this.getEntry(key);
        if (entry)
            return entry[1];
    }
    getOrElse(key, fallback) {
        const entry = this.getEntry(key);
        return entry ? entry[1] : fallback;
    }
    getEntry(key) {
        const hash = this._hashFactory(key);
        return this._store.get(hash);
    }
    getOrSet(key, factory) {
        const hash = this._hashFactory(key);
        const entry = this._store.get(hash);
        if (!entry) {
            const value = factory(key, this);
            if (value instanceof Promise) {
                return this.addAsync(hash, key, value);
            }
            this._store.set(hash, [key, value]);
            return value;
        }
        return entry[1];
    }
    async addAsync(hash, key, valuePromise) {
        const value = await valuePromise;
        this._store.set(hash, [key, value]);
        return value;
    }
    set(key, value) {
        const hash = this._hashFactory(key);
        this._store.set(hash, [key, value]);
        return this;
    }
    delete(key) {
        const hash = this._hashFactory(key);
        return this._store.delete(hash);
    }
    clear() {
        this._store.clear();
    }
    forEach(callbackfn, thisArg) {
        for (const [key, value] of this) {
            callbackfn.call(thisArg, value, key, this);
        }
    }
    *keys() {
        for (const [k, _] of this) {
            yield k;
        }
    }
    *values() {
        for (const [_, v] of this) {
            yield v;
        }
    }
    *entries() {
        for (const entry of this._store.values()) {
            yield [...entry];
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    *mapEntries(entries) {
        if (entries) {
            for (const [k, v] of entries) {
                yield [this._hashFactory(k), [k, v]];
            }
        }
    }
}class HashSet {
    constructor(hashFactory = String, values) {
        this._hashFactory = hashFactory;
        this._store = new Map(this.mapEntries(values));
    }
    get size() { return this._store.size; }
    get [Symbol.toStringTag]() { return "[Object HashSet]"; }
    has(key) {
        const hash = this._hashFactory(key);
        return this._store.has(hash);
    }
    add(key) {
        const hash = this._hashFactory(key);
        this._store.set(hash, key);
        return this;
    }
    delete(key) {
        const hash = this._hashFactory(key);
        return this._store.delete(hash);
    }
    clear() {
        this._store.clear();
    }
    forEach(callbackfn, thisArg) {
        for (const key of this) {
            callbackfn.call(thisArg, key, key, this);
        }
    }
    keys() {
        return this._store.values();
    }
    *entries() {
        for (const item of this._store.values()) {
            yield [item, item];
        }
    }
    values() {
        return this.keys();
    }
    [Symbol.iterator]() {
        return this.keys();
    }
    *mapEntries(entries) {
        if (entries) {
            for (const k of entries) {
                yield [this._hashFactory(k), k];
            }
        }
    }
}class Lookup {
    constructor(hashFactory) {
        this._store = hashFactory ? new HashMap(hashFactory) : new Map();
        this._itemSize = 0;
    }
    get size() { return this._store.size; }
    get itemSize() { return this._itemSize; }
    get [Symbol.toStringTag]() { return "[Object Lookup]"; }
    has(key) {
        return this._store.has(key);
    }
    hasValue(key, value) {
        var _a;
        const entries = this._store.get(key);
        return (_a = entries === null || entries === void 0 ? void 0 : entries.includes(value)) !== null && _a !== void 0 ? _a : false;
    }
    include(value) {
        for (const val of this.values()) {
            if (val === value)
                return true;
        }
        return false;
    }
    first(key) {
        const entries = this._store.get(key);
        if (entries)
            return entries[0];
    }
    last(key) {
        const entries = this._store.get(key);
        if (entries)
            return entries[entries.length - 1];
    }
    *get(key) {
        const entries = this._store.get(key);
        if (entries)
            yield* entries;
    }
    add(key, ...values) {
        const entries = this._store.get(key);
        if (entries) {
            entries.push(...values);
        }
        else {
            this._store.set(key, values);
        }
        this._itemSize++;
        return this;
    }
    delete(key) {
        const entries = this._store.get(key);
        if (entries) {
            this._itemSize -= entries.length;
            return this._store.delete(key);
        }
        return false;
    }
    deleteValue(key, value) {
        const entries = this._store.get(key);
        if (entries) {
            const idx = entries.indexOf(value);
            if (idx !== -1) {
                if (entries.length === 1) {
                    this._store.delete(key);
                }
                else {
                    entries.splice(idx, 1);
                }
                this._itemSize--;
                return true;
            }
        }
        return false;
    }
    clear() {
        this._itemSize = 0;
        this._store.clear();
    }
    forEach(callbackfn, thisArg) {
        for (const [key, values] of this._store) {
            for (const value of values) {
                callbackfn.call(thisArg, value, key, this);
            }
        }
    }
    *keys() {
        yield* this._store.keys();
    }
    *values() {
        for (const values of this._store.values()) {
            yield* values;
        }
    }
    *[Symbol.iterator]() {
        yield* this._store;
    }
    static create(values, hashFactory) {
        const lookup = new Lookup(hashFactory);
        for (const item of values) {
            lookup.add(...item);
        }
        return lookup;
    }
}/** Enumerate all available scopes */
var ServiceLifetime;
(function (ServiceLifetime) {
    /** New instance injected on each context */
    ServiceLifetime[ServiceLifetime["transient"] = 0] = "transient";
    /** Will create new instance on each scope */
    ServiceLifetime[ServiceLifetime["scoped"] = 1] = "scoped";
    /** Avalaible to current scope and all children */
    ServiceLifetime[ServiceLifetime["singleton"] = 2] = "singleton";
})(ServiceLifetime || (ServiceLifetime = {}));
/** Enumerate all available scopes */
var ServiceScope;
(function (ServiceScope) {
    /** The service is only available in current container */
    ServiceScope[ServiceScope["container"] = 1] = "container";
    /** The service is only available for children of current container */
    ServiceScope[ServiceScope["children"] = 2] = "children";
    /** The service is available for current container and its children */
    ServiceScope[ServiceScope["both"] = 3] = "both";
})(ServiceScope || (ServiceScope = {}));class ServiceRegistry {
    constructor(_resolver) {
        this._resolver = _resolver;
        this._serviceIds = new Map();
        this._dependencies = new Map();
    }
    *dependencies(ctor) {
        const deps = this._dependencies.get(ctor);
        if (deps)
            yield* deps.sort((l, r) => l.index - r.index);
    }
    get(tag) {
        const entry = this._serviceIds.get(tag);
        return entry ? entry[0] : null;
    }
    resolve(ctor) {
        const entry = this._serviceIds.get(ctor);
        if (entry)
            return entry[0];
        return this._resolver(ctor);
    }
    add(serviceId, options) {
        const tagId = ServiceIdentifierTag(serviceId);
        if (!tagId) {
            throw new Error(`Invalid service id: ${serviceId}`);
        }
        if (this._serviceIds.has(tagId)) {
            throw new Error(`Service "${options.name}" already exists.`);
        }
        this._serviceIds.set(tagId, [serviceId, options]);
    }
    addDependency(serviceCtor, serviceId, index, type) {
        const dependencies = this._dependencies.get(serviceCtor);
        if (dependencies) {
            dependencies.push({ serviceId, index, type });
            dependencies.sort((a, b) => a.index - b.index);
        }
        else {
            this._dependencies.set(serviceCtor, [{ serviceId, index, type }]);
        }
    }
}const serviceIdentityTag = Tag("IoC/ServiceId");
const ServiceIdentifierTag = serviceIdentityTag.readOnly();
const defaultOptions = { namespace: "local", unique: false, name: "" };
function ServiceIdentifier(nameOrOptions) {
    const options = typeof nameOrOptions === "string"
        ? Object.assign(Object.assign({}, defaultOptions), { name: nameOrOptions }) : Object.assign(Object.assign({}, defaultOptions), nameOrOptions);
    const fullName = getFullName(options);
    const hashValue = options.unique ? fullName : Symbol(fullName);
    return create(hashValue, options);
}
(function (ServiceIdentifier) {
    ServiceIdentifier.registry = new ServiceRegistry(of);
    /**
     * Returns a new service identifier for a specific type
     *
     * This method will strongly bind implementation to a specific type
     */
    function of(ctor) {
        return create(ctor, { name: ctor.name, namespace: "default" });
    }
    ServiceIdentifier.of = of;
    /** Check wether or not the provided object is a ServiceIdentifier */
    function is(target) {
        return serviceIdentityTag.has(target);
    }
    ServiceIdentifier.is = is;
})(ServiceIdentifier || (ServiceIdentifier = {}));
function create(tag, options) {
    const id = ((target, _, index) => {
        ServiceIdentifier.registry.addDependency(target, id, index, "required");
    });
    serviceIdentityTag.set(id, tag);
    Object.assign(id, createImpl(options));
    ServiceIdentifier.registry.add(id, options);
    return id;
}
function createImpl(options) {
    return {
        [Symbol.toPrimitive]: () => getFullName(options),
        toString: () => getFullName(options)
    };
}
function getFullName(options) {
    return `${options.namespace}/${options.name}`;
}function isAllowedScope(scope, owned) {
    if (owned) {
        return (scope & ServiceScope.container) === ServiceScope.container;
    }
    return (scope & ServiceScope.children) === ServiceScope.children;
}
function resolveServiceId(serviceIdOrCtor) {
    if (ServiceIdentifier.is(serviceIdOrCtor)) {
        return serviceIdOrCtor;
    }
    const serviceId = ServiceIdentifier.registry.resolve(serviceIdOrCtor);
    if (serviceId)
        return serviceId;
    throw new Error(`${serviceIdOrCtor} is neither a service id, neither a valid registered constructor.`);
}const _serviceContractTag = Tag("serviceContract");
function ServiceContract(serviceId) {
    return (target) => {
        _serviceContractTag.set(target, serviceId);
    };
}
(function (ServiceContract) {
    ServiceContract.Tag = _serviceContractTag.readOnly();
    function resolve(ctor) {
        var _a;
        return (_a = _serviceContractTag.get(ctor)) !== null && _a !== void 0 ? _a : ServiceIdentifier.registry.resolve(ctor);
    }
    ServiceContract.resolve = resolve;
})(ServiceContract || (ServiceContract = {}));/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};const IServiceAccessor = ServiceIdentifier({ namespace: "@aster-js/ioc", name: "IServiceAccessor", unique: true });function Optional(serviceId) {
    return (target, _, index) => {
        ServiceIdentifier.registry.addDependency(target, serviceId, index, "optional");
    };
}
function Many(serviceId) {
    return (target, _, index) => {
        ServiceIdentifier.registry.addDependency(target, serviceId, index, "many");
    };
}
function Options(serviceId) {
    return (target, _, index) => {
        ServiceIdentifier.registry.addDependency(target, serviceId, index, "options");
    };
}const _serviceFactoryTag = Tag("serviceFactory");
const ServiceFactoryTag = _serviceFactoryTag.readOnly();
var IServiceFactory;
(function (IServiceFactory) {
    function create(serviceId, callback, targetType) {
        let CallbackServiceFactory = class CallbackServiceFactory extends DisposableHost {
            constructor(_serviceAccessor) {
                super();
                this._serviceAccessor = _serviceAccessor;
                this.registerForDispose(_serviceAccessor);
            }
            create() {
                return callback(this._serviceAccessor);
            }
        };
        CallbackServiceFactory.targetType = targetType !== null && targetType !== void 0 ? targetType : Object;
        CallbackServiceFactory = __decorate([
            ServiceFactory(serviceId),
            __param(0, Optional(IServiceAccessor))
        ], CallbackServiceFactory);
        return CallbackServiceFactory;
    }
    IServiceFactory.create = create;
})(IServiceFactory || (IServiceFactory = {}));
const ServiceFactory = (serviceId) => {
    return (target) => {
        _serviceFactoryTag.set(target, serviceId);
    };
};class ServiceCollection extends DisposableHost {
    get size() { return this._store.size; }
    constructor(descriptors = []) {
        super();
        const values = ServiceCollection.entries(descriptors);
        this._store = Lookup.create(values, ServiceIdentifierTag.get);
    }
    has(serviceIdOrDescriptor) {
        if (ServiceIdentifier.is(serviceIdOrDescriptor)) {
            return this._store.has(serviceIdOrDescriptor);
        }
        const desc = serviceIdOrDescriptor;
        return this._store.hasValue(desc.serviceId, desc);
    }
    get(serviceId) {
        return this._store.get(serviceId);
    }
    add(desc) {
        this._store.add(desc.serviceId, desc);
        return this;
    }
    delete(desc) {
        this._store.deleteValue(desc.serviceId, desc);
        return this;
    }
    *[Symbol.iterator]() {
        for (const desc of this._store.values()) {
            yield desc;
        }
    }
    dispose() {
        IDisposable.safeDispose(this._store);
    }
    static *entries(descriptors) {
        for (const desc of descriptors) {
            yield [desc.serviceId, desc];
        }
    }
}class CallbackIterator {
    constructor(initialValue, _nextCallback) {
        this._nextCallback = _nextCallback;
        this._nextValue = initialValue;
    }
    next() {
        const value = this._nextValue;
        if (typeof value === "undefined") {
            return { value, done: true };
        }
        this._nextValue = this._nextCallback(value);
        return { value, done: false };
    }
}var Iterables;
(function (Iterables) {
    function cast(iterable) {
        return typeof iterable === "object" && iterable !== null
            && typeof Reflect.get(iterable, Symbol.iterator) === "function";
    }
    Iterables.cast = cast;
    function create(initialValue, nextCallback) {
        return {
            [Symbol.iterator]: () => {
                return new CallbackIterator(initialValue, nextCallback);
            }
        };
    }
    Iterables.create = create;
    function* filter(iterable, predicate) {
        for (const item of iterable)
            if (predicate(item))
                yield item;
    }
    Iterables.filter = filter;
    function has(iterable, filterPredicate) {
        for (const _ of build(iterable, filterPredicate))
            return true;
        return false;
    }
    Iterables.has = has;
    function first(iterable, filterPredicate) {
        for (const item of build(iterable, filterPredicate))
            return item;
    }
    Iterables.first = first;
    function last(iterable, filterPredicate) {
        const iterator = build(iterable, filterPredicate);
        let result;
        for (const item of iterator) {
            result = item;
        }
        return result;
    }
    Iterables.last = last;
    function build(iterable, filterPredicate) {
        filterPredicate !== null && filterPredicate !== void 0 ? filterPredicate : (filterPredicate = _ => true);
        return filter(iterable, filterPredicate);
    }
})(Iterables || (Iterables = {}));var Iterators;
(function (Iterators) {
    function create(initialValue, nextCallback) {
        return new CallbackIterator(initialValue, nextCallback);
    }
    Iterators.create = create;
})(Iterators || (Iterators = {}));class TopologicalIterator {
    constructor(src, _resolver, hashFactory) {
        this._resolver = _resolver;
        this._hashFactory = hashFactory !== null && hashFactory !== void 0 ? hashFactory : (x => x);
        this._resolveds = new HashSet(this._hashFactory);
        this._remaings = new HashMap(this._hashFactory, [...src].map(item => [item, [...this._resolver(item)]]));
    }
    next() {
        if (!this._remaings.size)
            return { value: void 0, done: true };
        for (let [node, deps] of this._remaings) {
            if (deps.every(d => this._resolveds.has(d) || this._hashFactory(d) === this._hashFactory(node))) {
                this._remaings.delete(node);
                this._resolveds.add(node);
                return { value: node, done: false };
            }
        }
        throw new Error(`Cyclic dependencies: Cannot resolve the provided dependency graph.`);
    }
}class TopologicalGraph {
    constructor(_hashFactory) {
        this._hashFactory = _hashFactory;
        this._nodes = new HashMap(_hashFactory);
    }
    has(node) {
        return this._nodes.has(node);
    }
    *get(node) {
        let deps = this._nodes.get(node);
        if (deps)
            yield* deps;
    }
    add(node, ...dependencies) {
        let deps = this._nodes.get(node);
        if (deps) {
            for (let dep of dependencies)
                deps.add(dep);
        }
        else {
            this._nodes.set(node, new HashSet(this._hashFactory, dependencies));
        }
    }
    delete(node) {
        return this._nodes.delete(node);
    }
    clear() {
        this._nodes.clear();
    }
    *nodes() {
        const keys = [...this._nodes.keys()];
        const results = new HashSet(this._hashFactory, keys);
        // Nodes without dependencies are returned first
        for (const values of this._nodes.values()) {
            for (const dep of values) {
                if (!results.has(dep)) {
                    results.add(dep);
                    yield dep;
                }
            }
        }
        // Last added supposedly have less dependencies
        yield* keys.reverse();
    }
    [Symbol.iterator]() {
        return new TopologicalIterator(this.nodes(), n => this.get(n), this._hashFactory);
    }
}const IAsyncActionQueryMixin = q => class extends q {
    async each(callback) {
        var _a, e_1, _b, _c;
        let rank = 0;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                await callback(item, rank++);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    }
};const IActionQueryMixin = q => class extends q {
    each(callback) {
        let rank = 0;
        for (const item of this) {
            callback(item, rank++);
        }
        return this;
    }
    async eachAsync(callback) {
        let rank = 0;
        for (const item of this) {
            await callback(item, rank++);
        }
        return this;
    }
};const IChunkAsyncQueryMixin = q => class extends q {
    chunk(chunkSize) {
        const callback = createFilterCallback$3(chunkSize);
        return this.transformAsync(callback);
    }
};
function createFilterCallback$3(chunkSize) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_1, _b, _c;
            const buffer = Array(chunkSize);
            let idx = 0;
            try {
                for (var _d = true, src_1 = __asyncValues(src), src_1_1; src_1_1 = yield __await(src_1.next()), _a = src_1_1.done, !_a; _d = true) {
                    _c = src_1_1.value;
                    _d = false;
                    const item = _c;
                    buffer[idx] = item;
                    if (++idx === chunkSize) {
                        idx = 0;
                        yield yield __await(buffer.slice(0));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_1.return)) yield __await(_b.call(src_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (idx) {
                yield yield __await(buffer.slice(0, idx));
            }
        });
    };
}const IChunkQueryMixin = q => class extends q {
    chunk(chunkSize) {
        const callback = createFilterCallback$2(chunkSize);
        return this.transform(callback);
    }
};
function createFilterCallback$2(chunkSize) {
    return function* (src) {
        const buffer = Array(chunkSize);
        let idx = 0;
        for (const item of src) {
            buffer[idx] = item;
            if (++idx === chunkSize) {
                idx = 0;
                yield buffer.slice(0);
            }
        }
        if (idx) {
            yield buffer.slice(0, idx);
        }
    };
}var DistinctList;
(function (DistinctList) {
    function create(comparer) {
        if (comparer) {
            return new DistinctArray([], comparer);
        }
        return new DistinctSet([]);
    }
    DistinctList.create = create;
    function fromValues(values, comparer) {
        if (comparer) {
            return new DistinctArray(values, comparer);
        }
        return new DistinctSet(values);
    }
    DistinctList.fromValues = fromValues;
})(DistinctList || (DistinctList = {}));
class DistinctSet {
    constructor(values) {
        this._values = new Set(values);
    }
    has(item) {
        return this._values.has(item);
    }
    tryAdd(item) {
        if (this.has(item))
            return false;
        this._values.add(item);
        return true;
    }
}
class DistinctArray {
    constructor(values, _comparer) {
        this._comparer = _comparer;
        this._values = [...values];
    }
    has(item) {
        return !this._values.every(x => !this._comparer(x, item));
    }
    tryAdd(item) {
        if (this.has(item))
            return false;
        this._values.push(item);
        return true;
    }
}const IFilterAsyncQueryMixin = q => class extends q {
    skipWhile(predicate) {
        const callback = createSkipWhileCallback$1(predicate);
        return this.transformAsync(callback);
    }
    takeWhile(predicate) {
        const callback = createTakeWhileCallback$1(predicate);
        return this.transformAsync(callback);
    }
    filter(predicate) {
        const callback = createFilterCallback$1(predicate);
        return this.transformAsync(callback);
    }
    ofType(predicate) {
        return this.filter(predicate);
    }
    distinct(comparer) {
        const predicate = createDistinctCallback$1(comparer);
        return this.transformAsync(predicate);
    }
    intersect(items, comparer) {
        const predicate = createIntersectCallback$1(items, comparer);
        return this.transformAsync(predicate);
    }
    except(items, comparer) {
        const predicate = createExceptCallback$1(items, comparer);
        return this.transformAsync(predicate);
    }
};
function createTakeWhileCallback$1(callback) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_1, _b, _c;
            let rank = 0;
            try {
                for (var _d = true, src_1 = __asyncValues(src), src_1_1; src_1_1 = yield __await(src_1.next()), _a = src_1_1.done, !_a; _d = true) {
                    _c = src_1_1.value;
                    _d = false;
                    const item = _c;
                    if (!(yield __await(callback(item, rank++))))
                        break;
                    yield yield __await(item);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_1.return)) yield __await(_b.call(src_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
}
function createSkipWhileCallback$1(callback) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_2, _b, _c;
            let rank = 0;
            let skip = true;
            try {
                for (var _d = true, src_2 = __asyncValues(src), src_2_1; src_2_1 = yield __await(src_2.next()), _a = src_2_1.done, !_a; _d = true) {
                    _c = src_2_1.value;
                    _d = false;
                    const item = _c;
                    if (skip) {
                        if (yield __await(callback(item, rank++)))
                            continue;
                        skip = false;
                    }
                    yield yield __await(item);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_2.return)) yield __await(_b.call(src_2));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    };
}
function createFilterCallback$1(callback) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_3, _b, _c;
            let rank = 0;
            try {
                for (var _d = true, src_3 = __asyncValues(src), src_3_1; src_3_1 = yield __await(src_3.next()), _a = src_3_1.done, !_a; _d = true) {
                    _c = src_3_1.value;
                    _d = false;
                    const item = _c;
                    if (yield __await(callback(item, rank++)))
                        yield yield __await(item);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_3.return)) yield __await(_b.call(src_3));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    };
}
function createDistinctCallback$1(comparer) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_4, _b, _c;
            const items = DistinctList.create(comparer);
            try {
                for (var _d = true, src_4 = __asyncValues(src), src_4_1; src_4_1 = yield __await(src_4.next()), _a = src_4_1.done, !_a; _d = true) {
                    _c = src_4_1.value;
                    _d = false;
                    const item = _c;
                    if (items.tryAdd(item))
                        yield yield __await(item);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_4.return)) yield __await(_b.call(src_4));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    };
}
function createIntersectCallback$1(values, comparer) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_5, _b, _c;
            const except = DistinctList.fromValues(values, comparer);
            try {
                for (var _d = true, src_5 = __asyncValues(src), src_5_1; src_5_1 = yield __await(src_5.next()), _a = src_5_1.done, !_a; _d = true) {
                    _c = src_5_1.value;
                    _d = false;
                    const item = _c;
                    if (except.has(item))
                        yield yield __await(item);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_5.return)) yield __await(_b.call(src_5));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    };
}
function createExceptCallback$1(values, comparer) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_6, _b, _c;
            const except = DistinctList.fromValues(values, comparer);
            try {
                for (var _d = true, src_6 = __asyncValues(src), src_6_1; src_6_1 = yield __await(src_6.next()), _a = src_6_1.done, !_a; _d = true) {
                    _c = src_6_1.value;
                    _d = false;
                    const item = _c;
                    if (!except.has(item))
                        yield yield __await(item);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_6.return)) yield __await(_b.call(src_6));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    };
}const IFilterQueryMixin = q => class extends q {
    skipWhile(predicate) {
        const callback = createSkipWhileCallback(predicate);
        return this.transform(callback);
    }
    takeWhile(predicate) {
        const callback = createTakeWhileCallback(predicate);
        return this.transform(callback);
    }
    filter(predicate) {
        const callback = createFilterCallback(predicate);
        return this.transform(callback);
    }
    ofType(predicate) {
        return this.filter(predicate);
    }
    distinct(comparer) {
        const predicate = createDistinctCallback(comparer);
        return this.transform(predicate);
    }
    intersect(items, comparer) {
        const predicate = createIntersectCallback(items, comparer);
        return this.transform(predicate);
    }
    except(items, comparer) {
        const predicate = createExceptCallback(items, comparer);
        return this.transform(predicate);
    }
};
function createTakeWhileCallback(callback) {
    return function* (src) {
        let rank = 0;
        for (const item of src) {
            if (!callback(item, rank++))
                break;
            yield item;
        }
    };
}
function createSkipWhileCallback(callback) {
    return function* (src) {
        let rank = 0;
        let skip = true;
        for (const item of src) {
            if (skip) {
                if (callback(item, rank++))
                    continue;
                skip = false;
            }
            yield item;
        }
    };
}
function createFilterCallback(callback) {
    return function* (src) {
        let rank = 0;
        for (const item of src) {
            if (callback(item, rank++))
                yield item;
        }
    };
}
function createDistinctCallback(comparer) {
    return function* (src) {
        const items = DistinctList.create(comparer);
        for (const item of src) {
            if (items.tryAdd(item))
                yield item;
        }
    };
}
function createIntersectCallback(values, comparer) {
    return function* (src) {
        const except = DistinctList.fromValues(values, comparer);
        for (const item of src) {
            if (except.has(item))
                yield item;
        }
    };
}
function createExceptCallback(values, comparer) {
    return function* (src) {
        const except = DistinctList.fromValues(values, comparer);
        for (const item of src) {
            if (!except.has(item))
                yield item;
        }
    };
}const ILookupAsyncQueryMixin = q => class extends q {
    async lookup(keyPredicate, hashFactory, valuePredicate) {
        var _a, e_1, _b, _c;
        valuePredicate !== null && valuePredicate !== void 0 ? valuePredicate : (valuePredicate = item => item);
        const lookup = new Lookup(hashFactory);
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                lookup.add(keyPredicate(item), valuePredicate(item));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return lookup;
    }
};const ILookupQueryMixin = q => class extends q {
    lookup(keyPredicate, hashFactory, valuePredicate) {
        valuePredicate !== null && valuePredicate !== void 0 ? valuePredicate : (valuePredicate = item => item);
        const lookup = new Lookup(hashFactory);
        for (const item of this) {
            lookup.add(keyPredicate(item), valuePredicate(item));
        }
        return lookup;
    }
};const IMapAsyncQueryMixin = q => class extends q {
    map(callback) {
        const predicate = createMapCallback$1(callback);
        return this.transformAsync(predicate);
    }
    flatMap(callback) {
        const predicate = createFlatMapCallback$1(callback);
        return this.transformAsync(predicate);
    }
};
function createMapCallback$1(callback) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_1, _b, _c;
            let rank = 0;
            try {
                for (var _d = true, src_1 = __asyncValues(src), src_1_1; src_1_1 = yield __await(src_1.next()), _a = src_1_1.done, !_a; _d = true) {
                    _c = src_1_1.value;
                    _d = false;
                    const item = _c;
                    yield yield __await(yield __await(callback(item, rank++)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_1.return)) yield __await(_b.call(src_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
}
function createFlatMapCallback$1(callback) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_2, _b, _c;
            let rank = 0;
            try {
                for (var _d = true, src_2 = __asyncValues(src), src_2_1; src_2_1 = yield __await(src_2.next()), _a = src_2_1.done, !_a; _d = true) {
                    _c = src_2_1.value;
                    _d = false;
                    const item = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(callback(item, rank++))));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_2.return)) yield __await(_b.call(src_2));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    };
}const IMapQueryMixin = q => class extends q {
    map(callback) {
        const predicate = createMapCallback(callback);
        return this.transform(predicate);
    }
    flatMap(callback) {
        const predicate = createFlatMapCallback(callback);
        return this.transform(predicate);
    }
};
function createMapCallback(callback) {
    return function* (src) {
        let rank = 0;
        for (const item of src) {
            yield callback(item, rank++);
        }
    };
}
function createFlatMapCallback(callback) {
    return function* (src) {
        let rank = 0;
        for (const item of src) {
            yield* callback(item, rank++);
        }
    };
}const NotFound$1 = Symbol();
const IScalarAsyncQueryMixin = q => class extends q {
    async includes(value, comparer = Object.is) {
        var _a, e_1, _b, _c;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                if (comparer(value, item))
                    return true;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    }
    async hasAny(predicate) {
        var _a, e_2, _b, _c;
        predicate !== null && predicate !== void 0 ? predicate : (predicate = _ => true);
        let rank = 0;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                if (await predicate(item, rank++))
                    return true;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
    }
    async every(predicate) {
        var _a, e_3, _b, _c;
        let rank = 0;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                if (!await predicate(item, rank++))
                    return false;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return true;
    }
    async first(fallback) {
        var _a, e_4, _b, _c;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                return item;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return fallback;
    }
    async findFirst(predicate, fallback) {
        var _a, e_5, _b, _c;
        let rank = 0;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                if (await predicate(item, rank++))
                    return item;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return fallback;
    }
    async findLast(predicate, fallback) {
        var _a, e_6, _b, _c;
        let rank = 0;
        let last = NotFound$1;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                if (await predicate(item, rank++))
                    last = item;
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return last !== NotFound$1 ? last : fallback;
    }
    async last(fallback) {
        var _a, e_7, _b, _c;
        let result = fallback;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                result = item;
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return result;
    }
    async count() {
        var _a, e_8, _b, _c;
        let result = 0;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const _ = _c;
                result++;
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return result;
    }
    async reduce(reducer, seed) {
        var _a, e_9, _b, _c;
        let previous = seed;
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                previous = await reducer(previous, item);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_9) throw e_9.error; }
        }
        return previous;
    }
};const NotFound = Symbol();
const IScalarQueryMixin = q => class extends q {
    includes(value, comparer = Object.is) {
        for (const item of this)
            if (comparer(value, item))
                return true;
        return false;
    }
    hasAny(predicate) {
        predicate !== null && predicate !== void 0 ? predicate : (predicate = _ => true);
        let rank = 0;
        for (const item of this)
            if (predicate(item, rank++))
                return true;
        return false;
    }
    every(predicate) {
        let rank = 0;
        for (const item of this)
            if (!predicate(item, rank++))
                return false;
        return true;
    }
    first(fallback) {
        for (const item of this)
            return item;
        return fallback;
    }
    findFirst(predicate, fallback) {
        let rank = 0;
        for (const item of this)
            if (predicate(item, rank++))
                return item;
        return fallback;
    }
    findLast(predicate, fallback) {
        let rank = 0;
        let last = NotFound;
        for (const item of this)
            if (predicate(item, rank++))
                last = item;
        return last !== NotFound ? last : fallback;
    }
    last(fallback) {
        let result = fallback;
        for (const item of this)
            result = item;
        return result;
    }
    count() {
        let result = 0;
        for (const _ of this)
            result++;
        return result;
    }
    reduce(reducer, seed) {
        let previous = seed;
        for (const item of this)
            previous = reducer(previous, item);
        return previous;
    }
};const ISliceAsyncQueryMixin = q => class extends q {
    skip(skip) {
        const predicate = createSlicePredicate$1(skip, -1);
        return this.transformAsync(predicate);
    }
    take(take) {
        const predicate = createSlicePredicate$1(0, take);
        return this.transformAsync(predicate);
    }
    slice(skip, take) {
        const predicate = createSlicePredicate$1(skip, take);
        return this.transformAsync(predicate);
    }
};
function createSlicePredicate$1(skip, take) {
    const end = skip + take - 1;
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            var _a, e_1, _b, _c;
            let idx = 0;
            try {
                for (var _d = true, src_1 = __asyncValues(src), src_1_1; src_1_1 = yield __await(src_1.next()), _a = src_1_1.done, !_a; _d = true) {
                    _c = src_1_1.value;
                    _d = false;
                    const item = _c;
                    if (idx < skip)
                        continue;
                    if (idx > end)
                        break;
                    yield yield __await(item);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = src_1.return)) yield __await(_b.call(src_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
}const ISliceQueryMixin = q => class extends q {
    skip(skip) {
        const predicate = createSlicePredicate(skip, -1);
        return this.transform(predicate);
    }
    take(take) {
        const predicate = createSlicePredicate(0, take);
        return this.transform(predicate);
    }
    slice(skip, take) {
        const predicate = createSlicePredicate(skip, take);
        return this.transform(predicate);
    }
};
function createSlicePredicate(skip, take) {
    const end = skip + take - 1;
    return function* (src) {
        let idx = 0;
        for (const item of src) {
            if (idx < skip)
                continue;
            if (idx > end)
                break;
            yield item;
        }
    };
}const ISortAsyncQueryMixin = q => class extends q {
    sortBy(predicate, desc = false) {
        const lt = desc ? 1 : -1;
        const gt = desc ? -1 : 1;
        const sortFn = (left, right) => {
            const leftValue = predicate(left);
            const rightValue = predicate(right);
            if (leftValue == rightValue)
                return 0;
            return leftValue < rightValue ? lt : gt;
        };
        return this.sort(sortFn);
    }
};const ISortQueryMixin = q => class extends q {
    sortBy(predicate, desc = false) {
        const lt = desc ? 1 : -1;
        const gt = desc ? -1 : 1;
        const sortFn = (left, right) => {
            const leftValue = predicate(left);
            const rightValue = predicate(right);
            if (leftValue == rightValue)
                return 0;
            return leftValue < rightValue ? lt : gt;
        };
        return this.sort(sortFn);
    }
};const IUnionAsyncQueryMixin = q => class extends q {
    union(iterable) {
        const predicate = createUnion$1(iterable);
        return this.transformAsync(predicate);
    }
    append(item) {
        const predicate = createAppend$1(item);
        return this.transformAsync(predicate);
    }
    prepend(item) {
        const predicate = createPrepend$1(item);
        return this.transformAsync(predicate);
    }
};
function createUnion$1(iterable) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            yield __await(yield* __asyncDelegator(__asyncValues(src)));
            yield __await(yield* __asyncDelegator(__asyncValues(iterable)));
        });
    };
}
function createAppend$1(item) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            yield __await(yield* __asyncDelegator(__asyncValues(src)));
            yield yield __await(item);
        });
    };
}
function createPrepend$1(item) {
    return function (src) {
        return __asyncGenerator(this, arguments, function* () {
            yield yield __await(item);
            yield __await(yield* __asyncDelegator(__asyncValues(src)));
        });
    };
}const IUnionQueryMixin = q => class extends q {
    union(iterable) {
        const predicate = createUnion(iterable);
        return this.transform(predicate);
    }
    append(item) {
        const predicate = createAppend(item);
        return this.transform(predicate);
    }
    prepend(item) {
        const predicate = createPrepend(item);
        return this.transform(predicate);
    }
};
function createUnion(iterable) {
    return function* (src) {
        yield* src;
        yield* iterable;
    };
}
function createAppend(item) {
    return function* (src) {
        yield* src;
        yield item;
    };
}
function createPrepend(item) {
    return function* (src) {
        yield item;
        yield* src;
    };
}function QueryMixins(...mixins) {
    return function (ctor) {
        return mixins.reduce((prev, mixin) => mixin(prev), ctor);
    };
}const IIterableMixins = [
    IActionQueryMixin,
    IFilterQueryMixin,
    IMapQueryMixin,
    IScalarQueryMixin,
    ILookupQueryMixin,
    ISliceQueryMixin,
    IChunkQueryMixin,
    IUnionQueryMixin,
    ISortQueryMixin
];
const IAsyncIterableMixins = [
    IAsyncActionQueryMixin,
    IFilterAsyncQueryMixin,
    IMapAsyncQueryMixin,
    IChunkAsyncQueryMixin,
    IScalarAsyncQueryMixin,
    ILookupAsyncQueryMixin,
    ISliceAsyncQueryMixin,
    IUnionAsyncQueryMixin,
    ISortAsyncQueryMixin
];let QueryBase = class QueryBase {
    sort(sortFn) { throw new Error(); }
    transform(predicate) { throw new Error(); }
    transformAsync(predicate) { throw new Error(); }
    toArray() {
        return [...this];
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            yield __await(yield* __asyncDelegator(__asyncValues(this)));
        });
    }
};
QueryBase = __decorate([
    QueryMixins(...IIterableMixins)
], QueryBase);class ArrayQuery extends QueryBase {
    constructor(src) {
        super();
        this.src = src;
    }
    toArray() {
        return this.src.slice(0);
    }
    *[Symbol.iterator]() {
        yield* this.src;
    }
}let AsyncQueryBase = class AsyncQueryBase {
    transformAsync(predicate) { throw new Error(); }
    sort(sortFn) { throw new Error(); }
    fetch() { throw new Error(); }
    async toArray() {
        var _a, e_1, _b, _c;
        const values = [];
        try {
            for (var _d = true, _e = __asyncValues(this), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                values.push(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return values;
    }
};
AsyncQueryBase = __decorate([
    QueryMixins(...IAsyncIterableMixins)
], AsyncQueryBase);class IterableQuery extends QueryBase {
    constructor(src) {
        super();
        this.src = src;
    }
    *[Symbol.iterator]() {
        yield* this.src;
    }
}
class AsyncIterableQuery extends AsyncQueryBase {
    constructor(src) {
        super();
        this.src = src;
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            yield __await(yield* __asyncDelegator(__asyncValues(this.src)));
        });
    }
}class UnionQuery extends QueryBase {
    constructor(src, iterables) {
        super();
        this.src = src;
        this.iterables = iterables;
    }
    *[Symbol.iterator]() {
        yield* this.src;
        for (const item of this.iterables) {
            yield* item;
        }
    }
}
class AsyncUnionQuery extends AsyncQueryBase {
    constructor(src, iterables) {
        super();
        this.src = src;
        this.iterables = iterables;
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            yield __await(yield* __asyncDelegator(__asyncValues(this.src)));
            for (const item of this.iterables) {
                yield __await(yield* __asyncDelegator(__asyncValues(item)));
            }
        });
    }
}function combineSortFn(first, second) {
    return (left, right) => {
        const firstResult = first(left, right);
        if (firstResult !== 0)
            return firstResult;
        return second(left, right);
    };
}
class SortedQuery extends QueryBase {
    constructor(_iterable, _sortFn) {
        super();
        this._iterable = _iterable;
        this._sortFn = _sortFn;
    }
    thenBy(sortFn) {
        const newSortFn = combineSortFn(this._sortFn, sortFn);
        return new SortedQuery(this._iterable, newSortFn);
    }
    *[Symbol.iterator]() {
        const values = Array.isArray(this._iterable) ? this._iterable : [...this._iterable];
        yield* values.sort(this._sortFn);
    }
}
class AsyncSortQuery extends AsyncQueryBase {
    constructor(_iterable, _sortFn) {
        super();
        this._iterable = _iterable;
        this._sortFn = _sortFn;
    }
    thenBy(sortFn) {
        const newSortFn = combineSortFn(this._sortFn, sortFn);
        return new AsyncSortQuery(this._iterable, newSortFn);
    }
    async toArray() {
        var _a, e_1, _b, _c;
        const values = [];
        try {
            for (var _d = true, _e = __asyncValues(this._iterable), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const item = _c;
                values.push(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return values.sort(this._sortFn);
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this.toArray()))));
        });
    }
}class TransformQuery extends QueryBase {
    constructor(_iterable, _predicate) {
        super();
        this._iterable = _iterable;
        this._predicate = _predicate;
    }
    *[Symbol.iterator]() {
        yield* this._predicate(this._iterable);
    }
}
class AsyncTransformQuery extends AsyncQueryBase {
    constructor(_iterable, _predicate) {
        super();
        this._iterable = _iterable;
        this._predicate = _predicate;
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            var _b, e_1, _c, _d;
            try {
                for (var _e = true, _f = __asyncValues(this._predicate(this._iterable)), _g; _g = yield __await(_f.next()), _b = _g.done, !_b; _e = true) {
                    _d = _g.value;
                    _e = false;
                    const item = _d;
                    yield yield __await(item);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_e && !_b && (_c = _f.return)) yield __await(_c.call(_f));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
}function sort$1(sortFn) {
    return new SortedQuery(this, sortFn);
}
function transform(predicate) {
    return new TransformQuery(this, predicate);
}
function transformAsync$1(predicate) {
    return new AsyncTransformQuery(this, predicate);
}
Object.assign(QueryBase.prototype, { sort: sort$1, transform, transformAsync: transformAsync$1 });function transformAsync(predicate) {
    return new AsyncTransformQuery(this, predicate);
}
async function fetch() {
    const result = await this.toArray();
    return new ArrayQuery(result);
}
function sort(sortFn) {
    return new AsyncSortQuery(this, sortFn);
}
Object.assign(AsyncQueryBase.prototype, { sort, fetch, transformAsync });function Query(iterable, ...iterables) {
    if (Iterables.cast(iterable)) {
        if (iterables.length) {
            return new UnionQuery(iterable, iterables);
        }
        if (Array.isArray(iterable)) {
            return new ArrayQuery(iterable);
        }
        return new IterableQuery(iterable);
    }
    if (iterables.length) {
        return new AsyncUnionQuery(iterable, iterables);
    }
    return new AsyncIterableQuery(iterable);
}class ServiceDescriptor {
    constructor(serviceId, lifetime, scope, ctor, baseArgs, delayed) {
        this.serviceId = serviceId;
        this.lifetime = lifetime;
        this.scope = scope;
        this.ctor = ctor;
        this.baseArgs = baseArgs;
        this.delayed = delayed;
        this.targetType = ctor;
        this.validateArgs();
    }
    validateArgs() {
        const dependencies = ServiceIdentifier.registry.dependencies(this.targetType);
        const first = Iterables.first(dependencies);
        if (first) {
            if (first.index > this.baseArgs.length) {
                throw new Error(`Not enough arguments provided for service binding ${this.serviceId}. Provided: ${this.baseArgs.length}, Expected: ${first.index}`);
            }
            if (first.index < this.baseArgs.length) {
                throw new Error(`Too much arguments provided for service binding ${this.serviceId}. Provided: ${this.baseArgs.length}, Expected: ${first.index}`);
            }
        }
    }
}class ServiceFactoryDescriptor {
    constructor(serviceId, lifetime, scope, ctor, baseArgs, delayed) {
        this.serviceId = serviceId;
        this.lifetime = lifetime;
        this.scope = scope;
        this.ctor = ctor;
        this.baseArgs = baseArgs;
        this.delayed = delayed;
        this.targetType = ctor.targetType;
    }
}function createServiceDescriptor(serviceId, lifetime, ctor, { baseArgs = [], delayed = false, scope = ServiceScope.both }) {
    return new ServiceDescriptor(serviceId, lifetime, scope, ctor, baseArgs, delayed);
}
function tryAddServiceInternal$1($this, lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    var _a;
    if (ServiceIdentifier.is(servicerIdOrCtor)) {
        if ($this.has(servicerIdOrCtor))
            return $this;
        return $this.add(createServiceDescriptor(servicerIdOrCtor, lifetime, ctorOrOptions, options !== null && options !== void 0 ? options : {}));
    }
    const serviceId = ServiceContract.resolve(servicerIdOrCtor);
    if ($this.has(serviceId))
        return $this;
    return $this.add(createServiceDescriptor(serviceId, lifetime, servicerIdOrCtor, (_a = ctorOrOptions) !== null && _a !== void 0 ? _a : {}));
}
function addServiceInternal$1($this, lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    var _a;
    if (ServiceIdentifier.is(servicerIdOrCtor)) {
        return $this.add(createServiceDescriptor(servicerIdOrCtor, lifetime, ctorOrOptions, options !== null && options !== void 0 ? options : {}));
    }
    const serviceId = ServiceContract.resolve(servicerIdOrCtor);
    return $this.add(createServiceDescriptor(serviceId, lifetime, servicerIdOrCtor, (_a = ctorOrOptions) !== null && _a !== void 0 ? _a : {}));
}
function addService(lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal$1(this, lifetime, servicerIdOrCtor, ctorOrOptions, options);
}
function addScoped(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal$1(this, ServiceLifetime.scoped, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddScoped(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal$1(this, ServiceLifetime.scoped, servicerIdOrCtor, ctorOrOptions, options);
}
function addSingleton(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal$1(this, ServiceLifetime.singleton, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddSingleton(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal$1(this, ServiceLifetime.singleton, servicerIdOrCtor, ctorOrOptions, options);
}
function addTransient(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal$1(this, ServiceLifetime.transient, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddTransient(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal$1(this, ServiceLifetime.transient, servicerIdOrCtor, ctorOrOptions, options);
}
Object.assign(ServiceCollection.prototype, {
    addService,
    addScoped, tryAddScoped,
    addSingleton, tryAddSingleton,
    addTransient, tryAddTransient
});function createServiceFactoryDescriptor(serviceId, lifetime, ctor, { baseArgs = [], delayed = false, scope = ServiceScope.both }) {
    return new ServiceFactoryDescriptor(serviceId, lifetime, scope, ctor, baseArgs, delayed);
}
function tryAddServiceInternal($this, lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    var _a;
    if (ServiceIdentifier.is(servicerIdOrCtor)) {
        if ($this.has(servicerIdOrCtor))
            return $this;
        return $this.add(createServiceFactoryDescriptor(servicerIdOrCtor, lifetime, ctorOrOptions, options !== null && options !== void 0 ? options : {}));
    }
    const serviceId = ServiceFactoryTag.get(servicerIdOrCtor);
    assertServiceFactoryId(serviceId);
    if ($this.has(serviceId))
        return $this;
    return $this.add(createServiceFactoryDescriptor(serviceId, lifetime, servicerIdOrCtor, (_a = ctorOrOptions) !== null && _a !== void 0 ? _a : {}));
}
function addServiceInternal($this, lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    var _a;
    if (ServiceIdentifier.is(servicerIdOrCtor)) {
        return $this.add(createServiceFactoryDescriptor(servicerIdOrCtor, lifetime, ctorOrOptions, options !== null && options !== void 0 ? options : {}));
    }
    const serviceId = ServiceFactoryTag.get(servicerIdOrCtor);
    assertServiceFactoryId(serviceId);
    return $this.add(createServiceFactoryDescriptor(serviceId, lifetime, servicerIdOrCtor, (_a = ctorOrOptions) !== null && _a !== void 0 ? _a : {}));
}
function assertServiceFactoryId(serviceId) {
    if (!serviceId)
        throw new Error("No service id attached to the provided factory. Use the @ServiceFactory decorator or provide explicitly the service id");
}
function addServiceFactory(lifetime, servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal(this, lifetime, servicerIdOrCtor, ctorOrOptions, options);
}
function addScopedFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal(this, ServiceLifetime.scoped, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddScopedFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal(this, ServiceLifetime.scoped, servicerIdOrCtor, ctorOrOptions, options);
}
function addSingletonFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal(this, ServiceLifetime.singleton, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddSingletonFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal(this, ServiceLifetime.singleton, servicerIdOrCtor, ctorOrOptions, options);
}
function addTransientFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return addServiceInternal(this, ServiceLifetime.transient, servicerIdOrCtor, ctorOrOptions, options);
}
function tryAddTransientFactory(servicerIdOrCtor, ctorOrOptions, options) {
    return tryAddServiceInternal(this, ServiceLifetime.transient, servicerIdOrCtor, ctorOrOptions, options);
}
Object.assign(ServiceCollection.prototype, {
    addServiceFactory,
    addScopedFactory, tryAddScopedFactory,
    addSingletonFactory, tryAddSingletonFactory,
    addTransientFactory, tryAddTransientFactory
});function addInstance(servicerIdOrInstance, instanceOrOptions, options = {}) {
    let instance;
    let serviceId;
    if (ServiceIdentifier.is(servicerIdOrInstance)) {
        serviceId = servicerIdOrInstance;
        instance = instanceOrOptions;
    }
    else {
        instance = servicerIdOrInstance;
        serviceId = resolveServiceId(instance.constructor);
    }
    const { delayed = false, scope = ServiceScope.both } = options;
    class CustomInstanceServiceFactory {
        create() { return instance; }
    }
    CustomInstanceServiceFactory.targetType = instance.constructor;
    const desc = new ServiceFactoryDescriptor(serviceId, ServiceLifetime.singleton, scope, CustomInstanceServiceFactory, [], delayed);
    return this.add(desc);
}
Object.assign(ServiceCollection.prototype, {
    addInstance
});const IServiceProvider = ServiceIdentifier({ namespace: "@aster-js/ioc", name: "IServiceProvider", unique: true });const ProxyInstance = Symbol();
class ServiceProxy extends DisposableHost {
    get proxy() { return this._proxy; }
    constructor(service) {
        super();
        const { proxy, revoke } = Proxy.revocable(service, this);
        this._proxy = proxy;
        this._service = service;
        this._revoke = revoke;
    }
    has(target, p) {
        return p in target;
    }
    get(target, p) {
        if (p === ProxyInstance)
            return this._service;
        const value = target[p];
        if (typeof value === "function") {
            return (...args) => {
                const r = value.apply(target, args);
                return r === target ? this._proxy : r;
            };
        }
        return value;
    }
    set(target, p, value) {
        target[p] = value;
        return true;
    }
    deleteProperty(target, p) {
        delete target[p];
        return true;
    }
    getPrototypeOf(target) {
        return Object.getPrototypeOf(target);
    }
    dispose() {
        this._revoke();
    }
}/** @inheritdoc */
let ServiceAccessor = class ServiceAccessor extends DisposableHost {
    constructor(_serviceProvider) {
        super();
        this._serviceProvider = _serviceProvider;
        this._proxies = new HashMap();
    }
    get(serviceId, required) {
        this.checkIfDisposed();
        const instance = this._serviceProvider.get(serviceId, required);
        if (instance)
            return this.getProxy(instance);
    }
    *getMany(serviceId, currentScopeOnly) {
        this.checkIfDisposed();
        for (const instance of this._serviceProvider.getAll(serviceId, currentScopeOnly)) {
            yield this.getProxy(instance);
        }
    }
    getProxy(instance) {
        const serviceProxy = this._proxies.getOrSet(instance, () => new ServiceProxy(instance));
        return serviceProxy === null || serviceProxy === void 0 ? void 0 : serviceProxy.proxy;
    }
    dispose() {
        const proxies = this._proxies.values();
        IDisposable.safeDisposeAll(proxies);
    }
};
ServiceAccessor = __decorate([
    ServiceContract(IServiceAccessor),
    __param(0, IServiceProvider)
], ServiceAccessor);const IDependencyResolver = ServiceIdentifier({ namespace: "@aster-js/ioc", name: "IDependencyResolver", unique: true });const IInstantiationService = ServiceIdentifier({ namespace: "@aster-js/ioc", name: "IInstantiationService", unique: true });class AsyncEventIterator {
    constructor(target, queueMaxSize) {
        this._handle = target(this.onDidEventEmitted, this);
        this._queueMaxSize = queueMaxSize;
        this._next = null;
        this._pendingQueue = [];
    }
    onDidEventEmitted(...args) {
        const next = this._next;
        if (next) {
            this._next = null;
            next(args);
        }
        else if (this._pendingQueue) {
            if (this._queueMaxSize !== -1 && this._pendingQueue.length >= this._queueMaxSize) {
                throw new Error(`Event iterator queue max size reached: ${this._queueMaxSize} are pending`);
            }
            this._pendingQueue.push(args);
        }
    }
    next() {
        if (!this._pendingQueue)
            throw new Error("Cannot reuse a terminated iterator");
        if (this._pendingQueue.length) {
            return Promise.resolve({
                value: this._pendingQueue.shift(),
                done: false
            });
        }
        return new Promise(resolve => {
            this._next = (args) => {
                resolve({
                    value: args,
                    done: false
                });
            };
        });
    }
    async return() {
        this.dispose();
        return {
            value: null,
            done: true
        };
    }
    [IDisposable.dispose]() {
        if (this._handle) {
            this.dispose();
        }
    }
    dispose() {
        IDisposable.safeDispose(this._handle);
        this._handle = null;
        this._pendingQueue = null;
    }
}var IEvent;
(function (IEvent) {
    function create(emitter) {
        const event = ((handler, thisArgs) => {
            handler = thisArgs ? handler.bind(thisArgs) : handler;
            emitter.addHandler(handler);
            const result = IDisposable.create(() => emitter.removeHandler(handler));
            if (thisArgs instanceof DisposableHost) {
                thisArgs.registerForDispose(result);
            }
            return result;
        });
        Reflect.set(event, Symbol.asyncIterator, () => new AsyncEventIterator(event, emitter.iteratorQueueMaxSize));
        if (emitter.async)
            Reflect.set(event, "async", true);
        return event;
    }
    IEvent.create = create;
    /**
     * Returns the next event arguments passed to the provided event
     * @param event Event to listen
     * @returns Arguments passed to the emitter
     */
    function next(event) {
        return new Promise((f) => {
            const handler = event.async
                ? event(async (...args) => {
                    IDisposable.safeDispose(handler);
                    f(args);
                })
                : event((...args) => {
                    IDisposable.safeDispose(handler);
                    f(args);
                });
        });
    }
    IEvent.next = next;
    /**
     * Listen and trigger the provided callback once and remove imediatly the listener to avoir further calls
     * @param event Event to listen
     * @param callback Callback to call once
     * @param thisArgs This context
     */
    function once(event, callback, thisArgs) {
        const handler = event.async
            ? event(async (...args) => {
                IDisposable.safeDispose(handler);
                await callback.call(thisArgs, ...args);
            })
            : event((...args) => {
                IDisposable.safeDispose(handler);
                callback.call(thisArgs, ...args);
            });
    }
    IEvent.once = once;
})(IEvent || (IEvent = {}));const Memoize = (_, propertyKey, desc) => {
    if (typeof (desc === null || desc === void 0 ? void 0 : desc.get) !== "function") {
        throw new Error(`Invalid "@Memoize" target: "${String(propertyKey)}" is not a get accessor.`);
    }
    desc.get = createGetter(propertyKey, desc.get);
    delete desc.set;
};
function createGetter(propertyKey, valueFactory) {
    const privateProp = Symbol(String(propertyKey));
    return function () {
        if (!Reflect.has(this, privateProp)) {
            const value = valueFactory.apply(this);
            if (!Reflect.set(this, privateProp, value)) {
                console.warn(`"@Memoize" cannot work properly on following instance, cannot memoize the value`, this);
            }
            return value;
        }
        return Reflect.get(this, privateProp);
    };
}function cacheResult(options = {}) {
    const values = new WeakMap();
    return (_target, key, descriptor) => {
        if (typeof descriptor.value === "function") {
            descriptor.value = createOverride(values, descriptor.value, options);
        }
        else if (typeof descriptor.get === "function") {
            descriptor.get = createOverride(values, descriptor.get, options);
        }
        else {
            throw new Error(`"${key}" is not supported by memoize decorator`);
        }
    };
}
function createOverride(values, fn, { ignoreUndefined, ignoreNull, ttl }) {
    return function (...args) {
        const entry = values.get(this);
        if (entry && (entry.timeout === -1 || entry.timeout > Date.now())) {
            return entry.value;
        }
        else {
            values.delete(this);
        }
        const value = fn.apply(this, args);
        if ((typeof value === "undefined" && ignoreUndefined)
            || (value === null && ignoreNull)) {
            return value;
        }
        values.set(this, { value, timeout: ttl ? Date.now() + ttl : -1 });
        return value;
    };
}const MAX_LISTENERS = 16;
const DISABLED_MAX = -1;
class EventEmitterBase extends DisposableHost {
    get size() { return this._handlers ? this._handlers.length : 0; }
    get maxSize() { var _a; return (_a = this._maxSize) !== null && _a !== void 0 ? _a : MAX_LISTENERS; }
    get iteratorQueueMaxSize() { var _a; return (_a = this._iteratorQueueMaxSize) !== null && _a !== void 0 ? _a : DISABLED_MAX; }
    constructor(options) {
        super();
        if (options) {
            if (typeof options.maxSize === "number") {
                this._maxSize = options.maxSize;
            }
            if (typeof options.iteratorQueueMaxSize === "number") {
                this._iteratorQueueMaxSize = options.iteratorQueueMaxSize;
            }
        }
    }
    *handlers() {
        if (this._handlers) {
            yield* this._handlers;
        }
    }
    addHandler(handler) {
        this.checkIfDisposed();
        if (this.maxSize !== DISABLED_MAX && this.size >= this.maxSize) {
            throw new Error(`Event max size reached: ${this.maxSize}`);
        }
        if (this._handlers) {
            this._handlers.push(handler);
        }
        else {
            this._handlers = [handler];
        }
    }
    removeHandler(handler) {
        if (this._handlers) {
            const idx = this._handlers.indexOf(handler);
            if (idx !== -1)
                this._handlers.splice(idx, 1);
        }
    }
    dispose() {
        delete this._handlers;
    }
}class EventEmitter extends EventEmitterBase {
    get event() { return IEvent.create(this); }
    emit(...args) {
        for (const callback of this.handlers()) {
            if (callback(...args) === false)
                break;
        }
    }
}
__decorate([
    Memoize
], EventEmitter.prototype, "event", null);class AsyncEventEmitter extends EventEmitterBase {
    get async() { return true; }
    get event() { return IEvent.create(this); }
    async emit(...args) {
        for (const callback of this.handlers()) {
            if (await callback(...args) === false)
                break;
        }
    }
}
__decorate([
    Memoize
], AsyncEventEmitter.prototype, "event", null);class InstantiationContext {
    constructor(target) {
        this.target = target;
        this._instances = new HashMap(e => e.uid);
    }
    setInstance(entry, instance) {
        this._instances.set(entry, instance);
    }
    getInstance(entry) {
        return this._instances.get(entry);
    }
}class InstantiationError extends Error {
    constructor(serviceId, err) {
        super(`Error during service instanciation for service id "${serviceId}": ${err.message}`, { cause: err });
    }
}const _self = Symbol("self");
const _serviceIdentityTag = Tag("service-identity");
let lastId = 0;
function setIdentity(target, desc, owner) {
    _serviceIdentityTag.set(target, {
        uuid: ++lastId,
        desc,
        owner
    });
    Reflect.set(target, _self, target);
}
var ServiceIdentity;
(function (ServiceIdentity) {
    function isProxy(svc) {
        return Reflect.get(svc, _self) === svc;
    }
    ServiceIdentity.isProxy = isProxy;
    function get(svc) {
        const instance = Reflect.get(svc, _self);
        if (typeof instance === "undefined")
            throw new Error("Service instance is not tagged with identity");
        return _serviceIdentityTag.get(instance);
    }
    ServiceIdentity.get = get;
    function fullName(svc) {
        const identity = _serviceIdentityTag.get(svc);
        if (identity) {
            return `${identity.desc.serviceId}`;
        }
    }
    ServiceIdentity.fullName = fullName;
})(ServiceIdentity || (ServiceIdentity = {}));let InstantiationService = class InstantiationService {
    get onDidServiceInstantiated() { return this._onDidServiceInstantiated.event; }
    constructor(_dependencyResolver, _serviceProvider) {
        this._dependencyResolver = _dependencyResolver;
        this._serviceProvider = _serviceProvider;
        this._onDidServiceInstantiated = new EventEmitter();
    }
    createService(desc) {
        const entry = this._dependencyResolver.resolveEntry(desc);
        if (entry) {
            if (!entry.desc.delayed) {
                return this.createServiceCore(entry);
            }
            return this.createDelayedService(entry);
        }
    }
    createServiceCore(entry) {
        const ctx = this.instanciateDependencyGraph(entry);
        return ctx.getInstance(entry);
    }
    createDelayedService(entry) {
        const lazyValue = new Lazy(() => this.createServiceCore(entry), entry.desc.ctor);
        const proxy = lazyValue.get();
        this.onInstanceCreated(entry.desc, proxy);
        return proxy;
    }
    instanciateService(entry, ctx) {
        const instance = entry.desc.delayed && ctx.target.uid !== entry.uid
            ? this.createDelayedService(entry)
            : this.createServiceInstance(entry, ctx);
        ctx.setInstance(entry, instance);
    }
    instanciateDependencyGraph(entry) {
        const graph = this._dependencyResolver.resolveDependencyGraph(entry);
        const ctx = new InstantiationContext(entry);
        const resolved = new Set();
        for (const node of graph.nodes()) {
            const instance = node.getScopeInstance();
            if (instance) {
                ctx.setInstance(node, instance);
                resolved.add(node);
            }
            else if (node.desc.delayed) {
                this.instanciateDependency(node, ctx);
                resolved.add(node);
            }
        }
        for (const node of graph) {
            if (resolved.has(node) && node.uid !== entry.uid)
                continue;
            this.instanciateDependency(node, ctx);
        }
        return ctx;
    }
    instanciateDependency(entry, ctx) {
        const instantiationSvc = entry.provider.get(IInstantiationService, true);
        instantiationSvc.instanciateService(entry, ctx);
    }
    createServiceInstance(entry, ctx) {
        asserts.defined(entry.dependencies);
        const dependencies = entry.dependencies.map(dep => dep.resolveArg(ctx));
        let instance = this.createInstance(entry.desc, entry.desc.ctor, [...entry.desc.baseArgs, ...dependencies]);
        if (entry.desc instanceof ServiceFactoryDescriptor) {
            const factory = instance;
            const lazyValue = new Lazy(() => {
                const instance = factory.create();
                try {
                    if (instance instanceof Promise) {
                        throw new Error(`ServiceFactory cannot return async results (${entry.desc.serviceId}`);
                    }
                }
                finally {
                    IDisposable.safeDispose(factory);
                }
                setIdentity(instance, entry.desc, this._serviceProvider);
                this.onInstanceCreated(entry.desc, instance);
                return instance;
            }, entry.desc.targetType);
            instance = lazyValue.get();
        }
        else {
            setIdentity(instance, entry.desc, this._serviceProvider);
        }
        this.onInstanceCreated(entry.desc, instance);
        return instance;
    }
    createInstance(desc, ctor, args) {
        try {
            return new ctor(...args);
        }
        catch (err) {
            if (err instanceof Error) {
                throw new InstantiationError(desc.serviceId, err);
            }
            else {
                const wrap = new Error(String(err));
                throw new InstantiationError(desc.serviceId, wrap);
            }
        }
    }
    onInstanceCreated(desc, instance) {
        this._onDidServiceInstantiated.emit(desc, instance);
    }
};
InstantiationService = __decorate([
    ServiceContract(IInstantiationService)
], InstantiationService);class ServiceEntry {
    constructor(uid, desc, provider, dependencies) {
        this.uid = uid;
        this.desc = desc;
        this.provider = provider;
        this.dependencies = dependencies;
        this.uid = uid;
        this.desc = desc;
        this.provider = provider;
    }
    getScopeInstance() {
        return this.provider.getOwnInstance(this.desc);
    }
    withDependencies(dependencies) {
        return new ServiceEntry(this.uid, this.desc, this.provider, dependencies);
    }
    static create(desc, provider) {
        const uid = `${Tags.hashId(desc)}-${Tags.hashId(provider)}`;
        return new ServiceEntry(uid, desc, provider);
    }
}class EmptyServiceDependency {
    constructor(param) {
        this.param = param;
    }
    resolveArg(_ctx) { }
    *entries() { }
}
class SingleServiceDependency {
    constructor(param, _entry) {
        this.param = param;
        this._entry = _entry;
    }
    resolveArg(ctx) {
        if (ctx) {
            return ctx.getInstance(this._entry);
        }
        return this._entry.provider.get(this._entry.desc);
    }
    getDependencyArg(_ctx) { }
    *entries() {
        yield this._entry;
    }
}
class MultipleServiceDependency {
    constructor(param, entries) {
        this.param = param;
        this._entries = [...entries];
    }
    resolveArg(ctx) {
        if (ctx) {
            return this._entries.map(e => ctx.getInstance(e));
        }
        return this._entries.map(e => e.provider.get(e.desc));
    }
    *entries() {
        yield* this._entries;
    }
}
class OptionsServiceDependency {
    constructor(param, entries) {
        this.param = param;
        this._entries = [...entries];
    }
    resolveArg(ctx) {
        const result = {};
        for (const opts of this.resolveOptions(ctx)) {
            Object.assign(result, opts);
        }
        return result;
    }
    *resolveOptions(ctx) {
        if (ctx) {
            for (const e of this._entries)
                yield ctx.getInstance(e);
        }
        else {
            for (const e of this._entries)
                yield e.provider.get(e.desc);
        }
    }
    *entries() {
        yield* this._entries;
    }
}let DependencyResolver = class DependencyResolver {
    constructor(_serviceProvider) {
        this._serviceProvider = _serviceProvider;
    }
    *resolveProviders(serviceId) {
        for (const svc of Iterables.create(this._serviceProvider, prev => prev.parent())) {
            const descriptors = svc.getOwnDescriptors(serviceId);
            if (Iterables.has(descriptors)) {
                yield svc;
            }
        }
    }
    resolveEntry(descriptorOrId) {
        if (ServiceIdentifier.is(descriptorOrId)) {
            const all = this.resolveEntries(descriptorOrId);
            return Iterables.first(all);
        }
        else {
            const all = this.resolveEntries(descriptorOrId.serviceId);
            return Iterables.first(all, entry => entry.desc === descriptorOrId);
        }
    }
    *resolveEntries(serviceId) {
        for (const svc of Iterables.create(this._serviceProvider, prev => prev.parent())) {
            for (const desc of svc.getOwnDescriptors(serviceId)) {
                if (isAllowedScope(desc.scope, svc === this._serviceProvider)) {
                    const provider = desc.lifetime === ServiceLifetime.scoped ? this._serviceProvider : svc;
                    yield ServiceEntry.create(desc, provider);
                }
            }
        }
    }
    *resolveDependencies(ctor) {
        for (const param of ServiceIdentifier.registry.dependencies(ctor)) {
            if (param.type === "many") {
                const entries = this.resolveEntries(param.serviceId);
                yield new MultipleServiceDependency(param, entries);
            }
            else if (param.type === "options") {
                const entries = this.resolveEntries(param.serviceId);
                yield new OptionsServiceDependency(param, entries);
            }
            else {
                const found = this.resolveEntry(param.serviceId);
                if (found) {
                    yield new SingleServiceDependency(param, found);
                }
                else if (param.type === "required") {
                    throw new Error(`No service named "${param.serviceId}" registered`);
                }
                else {
                    yield new EmptyServiceDependency(param);
                }
            }
        }
    }
    resolveDependencyGraph(entry) {
        const graph = new TopologicalGraph(entry => entry.uid);
        const stack = [entry];
        do {
            const entry = stack.pop();
            // Get the dependency resolver from the scope of the service
            const dependencyResolver = entry.provider.get(IDependencyResolver, true);
            const dependencies = [...dependencyResolver.resolveDependencies(entry.desc.ctor)];
            const serviceEntries = dependencies.flatMap(dep => [...dep.entries()]);
            graph.add(entry.withDependencies(dependencies), ...serviceEntries);
            const serviceToResolve = serviceEntries
                .filter(e => !graph.has(e) && !e.desc.delayed && !e.getScopeInstance());
            stack.push(...serviceToResolve);
        } while (stack.length);
        return graph;
    }
};
DependencyResolver = __decorate([
    ServiceContract(IDependencyResolver)
], DependencyResolver);var ServiceProvider_1;
let ServiceProvider = ServiceProvider_1 = class ServiceProvider {
    get size() { return Math.max(this._services.size, this._instances.size); }
    constructor(_services, _dependencyResolver, _instanciationService, _parent) {
        this._services = _services;
        this._dependencyResolver = _dependencyResolver;
        this._instanciationService = _instanciationService;
        this._parent = _parent;
        this._self = this; // Allow internal bypass for proxy ref
        this._instances = new Map();
        this.addCoreService(IDependencyResolver, this._dependencyResolver);
        this.addCoreService(IInstantiationService, this._instanciationService);
        this.addCoreService(IServiceProvider, this);
        this._instanciationService.onDidServiceInstantiated(this.onDidServiceInstantiated, this);
    }
    addCoreService(serviceId, instance) {
        const desc = new ServiceDescriptor(serviceId, ServiceLifetime.scoped, ServiceScope.container, instance.constructor, [], false);
        this._services.add(desc);
        this._instances.set(desc, instance);
    }
    onDidServiceInstantiated(desc, instance) {
        if (desc.lifetime !== ServiceLifetime.transient) {
            this._instances.set(desc, instance);
        }
    }
    createInstance(ctor, ...baseArgs) {
        const args = this.resolveArgs(ctor, baseArgs);
        return new ctor(...args);
    }
    resolve(ctor) {
        const resolveArgs = (baseArgs) => this.resolveArgs(ctor, baseArgs);
        return class extends ctor {
            constructor(...baseArgs) {
                super(...resolveArgs(baseArgs));
                this.injectedCallback && this.injectedCallback();
            }
        };
    }
    *resolveArgs(ctor, baseArgs) {
        const dependencies = [...this._dependencyResolver.resolveDependencies(ctor)];
        if (!dependencies.length)
            return baseArgs;
        const [first] = dependencies;
        if (baseArgs.length !== first.param.index) {
            throw new Error(`Invalid base arguments, expected ${first.param.index} arguments, provided ${baseArgs.length}`);
        }
        yield* baseArgs;
        for (const dependency of dependencies) {
            yield dependency.resolveArg();
        }
    }
    parent() {
        return this._parent;
    }
    getOwnDescriptors(serviceId) {
        return this._services.get(serviceId);
    }
    getOwnInstance(desc) {
        return this._instances.get(desc);
    }
    get(descriptorOrId, required = false, currentScopeOnly = false) {
        // Owned descriptor
        if (ServiceIdentifier.is(descriptorOrId)) {
            const descriptors = this._services.get(descriptorOrId);
            const first = Iterables.first(descriptors);
            if (first) {
                return this.fetchOrCreateOwnInstance(first, required, true);
            }
        }
        else if (this._services.has(descriptorOrId)) {
            return this.fetchOrCreateOwnInstance(descriptorOrId, required, true);
        }
        if (!currentScopeOnly) {
            // Not owned descriptor
            const entry = this._dependencyResolver.resolveEntry(descriptorOrId);
            if (entry) {
                return entry.provider.fetchOrCreateOwnInstance(entry.desc, required, false);
            }
        }
        if (required)
            throw new Error(`No binding found for "${descriptorOrId}" from current scope.`);
    }
    *getAll(serviceId, currentScopeOnly) {
        if (currentScopeOnly) {
            const descriptors = this._services.get(serviceId);
            yield* this.fetchOrCreateOwnInstances(descriptors);
        }
        else {
            for (const provider of this._dependencyResolver.resolveProviders(serviceId)) {
                if (provider._self === this._self) {
                    const descriptors = this._services.get(serviceId);
                    yield* this.fetchOrCreateOwnInstances(descriptors);
                }
                else {
                    const descriptors = Iterables.filter(this._services.get(serviceId), x => (x.scope & ServiceScope.children) === ServiceScope.children);
                    yield* this.fetchOrCreateOwnInstances(descriptors);
                }
            }
        }
    }
    fetchOrCreateOwnInstance(descriptor, required, owned) {
        if (isAllowedScope(descriptor.scope, owned)) {
            const instance = this.getOwnInstance(descriptor);
            if (!instance) {
                return this._instanciationService.createService(descriptor);
            }
            return instance;
        }
        else if (required) {
            throw new Error(`Attempting to create an instance of service scoped to children only: "${descriptor}".`);
        }
    }
    *fetchOrCreateOwnInstances(descriptors) {
        for (const descriptor of descriptors) {
            const instance = this.fetchOrCreateOwnInstance(descriptor, false, true);
            if (typeof instance !== "undefined")
                yield instance;
        }
    }
    [Symbol.dispose]() {
        const instances = [...this._instances.values()];
        this._instances.clear();
        IDisposable.safeDisposeAll(instances);
    }
    static create(services, parent) {
        let result;
        const lazyRef = Lazy.get(() => {
            if (!result) {
                throw new Error("Service provider not initialized.");
            }
            return result;
        });
        const dependencyResolver = new DependencyResolver(lazyRef);
        const instanciationService = new InstantiationService(dependencyResolver, lazyRef);
        result = new ServiceProvider_1(services, dependencyResolver, instanciationService, parent);
        this.setDefaultIdentity(IServiceProvider, ServiceProvider_1, parent !== null && parent !== void 0 ? parent : result);
        this.setDefaultIdentity(IDependencyResolver, DependencyResolver, result);
        this.setDefaultIdentity(IInstantiationService, InstantiationService, result);
        return result;
    }
    static setDefaultIdentity(serviceId, instance, owner) {
        const desc = new ServiceDescriptor(serviceId, ServiceLifetime.singleton, ServiceScope.container, instance.constructor, [], false);
        setIdentity(instance, desc, owner);
    }
};
ServiceProvider = ServiceProvider_1 = __decorate([
    ServiceContract(IServiceProvider)
], ServiceProvider);const IIoCModule = ServiceIdentifier({ namespace: "@aster-js/ioc", name: "IIoCModule", unique: true });
var IoCModuleSetupResultBehavior;
(function (IoCModuleSetupResultBehavior) {
    IoCModuleSetupResultBehavior[IoCModuleSetupResultBehavior["continue"] = 0] = "continue";
    IoCModuleSetupResultBehavior[IoCModuleSetupResultBehavior["stop"] = 1] = "stop";
})(IoCModuleSetupResultBehavior || (IoCModuleSetupResultBehavior = {}));
var IoCModuleSetupExecBehavior;
(function (IoCModuleSetupExecBehavior) {
    IoCModuleSetupExecBehavior[IoCModuleSetupExecBehavior["blocking"] = 0] = "blocking";
    IoCModuleSetupExecBehavior[IoCModuleSetupExecBehavior["asynchronous"] = 1] = "asynchronous";
})(IoCModuleSetupExecBehavior || (IoCModuleSetupExecBehavior = {}));var SetupErrorHandlerResult;
(function (SetupErrorHandlerResult) {
    SetupErrorHandlerResult[SetupErrorHandlerResult["stop"] = 0] = "stop";
    SetupErrorHandlerResult[SetupErrorHandlerResult["continue"] = 1] = "continue";
    SetupErrorHandlerResult[SetupErrorHandlerResult["throw"] = 2] = "throw";
})(SetupErrorHandlerResult || (SetupErrorHandlerResult = {}));
class SafeIoCModuleSetupAction {
    constructor() {
        this._execBehavior = IoCModuleSetupExecBehavior.blocking;
    }
    get execBehavior() { return this._execBehavior; }
    async exec(provider, token) {
        var _a;
        try {
            await this.execImpl(provider, token);
            return IoCModuleSetupResultBehavior.continue;
        }
        catch (err) {
            const behavior = (_a = this._errorHandler) === null || _a === void 0 ? void 0 : _a.call(this, err, provider);
            switch (behavior) {
                case undefined:
                case true:
                case SetupErrorHandlerResult.continue:
                    return IoCModuleSetupResultBehavior.continue;
                case SetupErrorHandlerResult.stop:
                case false:
                    return IoCModuleSetupResultBehavior.stop;
                case SetupErrorHandlerResult.throw:
                    throw err;
                default:
                    throw new Error("Invalid result");
            }
        }
    }
    continueWithoutAwaiting() {
        this._execBehavior = IoCModuleSetupExecBehavior.asynchronous;
    }
    onError(errorHandler) {
        this._errorHandler = errorHandler;
    }
}class IoCModuleCallbackSetupAction extends SafeIoCModuleSetupAction {
    constructor(_action) {
        super();
        this._action = _action;
    }
    async execImpl(provider, token) {
        const acc = provider.get(IServiceAccessor, true);
        await this._action(acc, token);
    }
}class IoCModuleServiceSetupAction extends SafeIoCModuleSetupAction {
    constructor(_serviceId, _action, _required) {
        super();
        this._serviceId = _serviceId;
        this._action = _action;
        this._required = _required;
    }
    async execImpl(provider, token) {
        const svc = provider.get(this._serviceId, this._required);
        if (svc)
            await this._action(svc, token);
    }
}class IoCModuleManyServiceSetupAction extends SafeIoCModuleSetupAction {
    constructor(_serviceId, _action, _currentScopeOnly) {
        super();
        this._serviceId = _serviceId;
        this._action = _action;
        this._currentScopeOnly = _currentScopeOnly;
    }
    async execImpl(provider, token) {
        const services = [...provider.getAll(this._serviceId, this._currentScopeOnly)];
        const all = services.map(x => this._action(x));
        await Promise.all(all);
    }
}let SetupIoCContainerBuilder$1=class SetupIoCContainerBuilder {
    constructor(_wrapped, _action) {
        this._wrapped = _wrapped;
        this._action = _action;
    }
    continueWithoutAwaiting() {
        this._action.continueWithoutAwaiting();
        return this._wrapped;
    }
    catch(errorHandler) {
        this._action.onError(errorHandler);
        return this._wrapped;
    }
    use(action) {
        return this._wrapped.use(action);
    }
    setup(serviceIdOrCtor, action, required = true) {
        return this._wrapped.setup(serviceIdOrCtor, action, required);
    }
    setupMany(serviceIdOrCtor, action, currentScopeOnly = true) {
        return this._wrapped.setupMany(serviceIdOrCtor, action, currentScopeOnly);
    }
    configure(action) {
        return this._wrapped.configure(action);
    }
    build() {
        return this._wrapped.build();
    }
};class IoCContainerBuilder extends DisposableHost {
    constructor(_name) {
        super();
        this._name = _name;
        this._setups = [];
        this._services = new ServiceCollection();
    }
    configure(action) {
        action(this._services);
        return this;
    }
    use(action) {
        this.checkIfDisposed();
        const setupAction = new IoCModuleCallbackSetupAction(action);
        return this.addSafeSetupAction(setupAction);
    }
    setup(serviceIdOrCtor, action, required = true) {
        this.checkIfDisposed();
        const serviceId = resolveServiceId(serviceIdOrCtor);
        const setupAction = new IoCModuleServiceSetupAction(serviceId, action, required);
        return this.addSafeSetupAction(setupAction);
    }
    setupMany(serviceIdOrCtor, action, currentScopeOnly = true) {
        this.checkIfDisposed();
        const serviceId = resolveServiceId(serviceIdOrCtor);
        const setupAction = new IoCModuleManyServiceSetupAction(serviceId, action, currentScopeOnly);
        return this.addSafeSetupAction(setupAction);
    }
    addSafeSetupAction(setupAction) {
        this._setups.push(setupAction);
        return new SetupIoCContainerBuilder$1(this, setupAction);
    }
    build() {
        this.checkIfDisposed();
        const services = new ServiceCollection(this._services);
        const provider = this.createServiceProvider(services);
        this.configureDefaultServices && this.configureDefaultServices(services, provider);
        const module = this.createModule(this._name, provider, [...this._setups]);
        services.addInstance(IIoCModule, module);
        return module;
    }
}class DeferredError extends Error {
}
class Deferred {
    constructor() {
        this._state = 0;
        this._version = 0;
    }
    get version() { return this._version; }
    get idle() { return this._state === 0; }
    get completed() { return Boolean(this._state & 1 /* DeferredState.completed */); }
    get succeed() { return Boolean(this._state & 4 /* DeferredState.succeed */); }
    get faulted() { return Boolean(this._state & 2 /* DeferredState.faulted */); }
    get disposed() { return Boolean(this._state & 8 /* DeferredState.disposed */); }
    resolve(value) {
        IDisposable.checkDisposed(this);
        if (!this._state) {
            this._state = 1 /* DeferredState.completed */ | 4 /* DeferredState.succeed */;
            this._promiseOrResult = value;
            this._resolveCallback && this._resolveCallback(value);
            return true;
        }
        return false;
    }
    reject(reason) {
        IDisposable.checkDisposed(this);
        if (!this._state) {
            this._state = 1 /* DeferredState.completed */ | 2 /* DeferredState.faulted */;
            const error = reason instanceof Error ? reason : new DeferredError(reason);
            this._promiseOrResult = error;
            this._rejectCallback && this._rejectCallback(error);
            return true;
        }
        return false;
    }
    cancel() {
        IDisposable.checkDisposed(this);
        if (!this._state) {
            this.resetCore();
            return true;
        }
        return false;
    }
    /**
     * Reset current deferred into idle state and rejecting any pending promise
     * > To avoid rejecting pending promise, use cancel
     * @param force Reset current promise and get a new one even if its not completed
     */
    reset(force) {
        IDisposable.checkDisposed(this);
        if (force) {
            if (!this._state && this._rejectCallback) {
                const err = new DeferredError("Operation cancelled");
                this._rejectCallback(err);
            }
            this.resetCore();
        }
        else if (this._state) {
            this.resetCore();
        }
    }
    resetCore() {
        this._version++;
        this._state = 0;
        delete this._promiseOrResult;
        delete this._resolveCallback;
        delete this._rejectCallback;
    }
    async then(onfulfilled, onrejected) {
        if (this._promiseOrResult instanceof Promise) {
            return this._promiseOrResult.then(onfulfilled, onrejected);
        }
        if (this._state & 4 /* DeferredState.succeed */) {
            if (onfulfilled)
                return onfulfilled(this._promiseOrResult);
        }
        if (this._state & 2 /* DeferredState.faulted */) {
            if (onrejected)
                return onrejected(this._promiseOrResult);
        }
        return this.initAwaiter().then(onfulfilled, onrejected);
    }
    async catch(onrejected) {
        try {
            return await this;
        }
        catch (err) {
            return await onrejected(err);
        }
    }
    async finally(onfinally) {
        try {
            return await this;
        }
        finally {
            onfinally();
        }
    }
    /**
     * Transform current instance into a native promise
     * > This method should be used carefully
     */
    getAwaiter() {
        if (this._promiseOrResult instanceof Promise) {
            return this._promiseOrResult;
        }
        if (this._state & 4 /* DeferredState.succeed */) {
            return Promise.resolve(this._promiseOrResult);
        }
        if (this._state & 2 /* DeferredState.faulted */) {
            return Promise.reject(this._promiseOrResult);
        }
        return this.initAwaiter();
    }
    initAwaiter() {
        const promise = new Promise((resolve, reject) => {
            this._resolveCallback = resolve;
            this._rejectCallback = reject;
        });
        this._promiseOrResult = promise;
        return promise;
    }
    [IDisposable.dispose]() {
        if (this._state !== 8 /* DeferredState.disposed */) {
            this.reject(new DisposedError());
            delete this._promiseOrResult;
            this._state = 8 /* DeferredState.disposed */;
        }
    }
    static resolve(value) {
        const d = new Deferred();
        d.resolve(value);
        return d;
    }
    static reject(reason) {
        const d = new Deferred();
        d.reject(reason);
        return d;
    }
}const NoValue = Symbol();
const Disposed = Symbol();
class Delayed {
    constructor() {
        this._value = NoValue;
    }
    get disposed() { return this._value === Disposed; }
    has() {
        IDisposable.checkDisposed(this);
        return this._value !== NoValue;
    }
    get() {
        IDisposable.checkDisposed(this);
        if (this._value !== NoValue)
            return this._value;
        if (!this._deferred)
            this._deferred = new Deferred();
        return this._deferred;
    }
    set(value) {
        var _a;
        IDisposable.checkDisposed(this);
        this._value = value;
        (_a = this._deferred) === null || _a === void 0 ? void 0 : _a.resolve(value);
    }
    reset() {
        IDisposable.checkDisposed(this);
        IDisposable.safeDispose(this._deferred);
        IDisposable.safeDispose(this._value);
        this._value = NoValue;
    }
    [IDisposable.dispose]() {
        IDisposable.safeDispose(this._deferred);
        IDisposable.safeDispose(this._value);
        this._value = Disposed;
    }
}class TimeoutSource {
    constructor() {
        this._timer = -1;
    }
    get hasPendingCall() { return this._timer !== -1; }
    /** Invoke the pending call and cancel any pending ones */
    invoke(callback, timeout) {
        this.clear();
        this.invokeCore(callback, timeout);
    }
    /** Invoke the provided callback if there is no pending call */
    tryInvoke(callback, timeout) {
        if (this._timer === -1) {
            this.invokeCore(callback, timeout);
            return true;
        }
        return false;
    }
    invokeCore(callback, timeout) {
        this._timer = self.setTimeout(() => {
            this._timer = -1;
            callback();
        }, timeout);
    }
    /** Cancel any pending calls */
    clear() {
        if (this._timer !== -1) {
            clearTimeout(this._timer);
            this._timer = -1;
        }
    }
    [IDisposable.dispose]() {
        this.clear();
    }
}const NO_VALUE = Symbol();
class AbortError extends Error {
}
var AbortToken;
(function (AbortToken) {
    AbortToken.none = Object.freeze({
        aborted: false,
        reason: null,
        signal: null,
        register: () => { },
        throwIfAborted: () => { }
    });
    /**
     * Create a new AbortableToken
     */
    function create(parent) {
        const token = new AbortableToken();
        if (parent)
            token.attach(parent);
        return token;
    }
    AbortToken.create = create;
    /**
     * Return whether or not the provided value is a valid token
     * @param token Token to validate
     */
    function isValidToken(token) {
        return token instanceof ReadOnlyAbortToken
            || token instanceof AbortableToken
            || token === AbortToken.none;
    }
    AbortToken.isValidToken = isValidToken;
})(AbortToken || (AbortToken = {}));
class ReadOnlyAbortToken {
    get aborted() { return this._source.aborted; }
    get reason() { return this._source.reason; }
    get signal() { return this._source.signal; }
    constructor(_source) {
        this._source = _source;
    }
    register(listener) {
        this._source.register(listener);
    }
    throwIfAborted() {
        this._source.throwIfAborted();
    }
}
class AbortableToken extends DisposableHost {
    constructor() {
        super(...arguments);
        this._listeners = [];
        this._controller = new AbortController();
        this._abortReason = NO_VALUE;
    }
    get aborted() { return this._abortReason !== NO_VALUE; }
    get reason() { return this._abortReason !== NO_VALUE ? this._abortReason : null; }
    /** Gets a ReadOnly token that will not be able to abort him by itself */
    get readOnly() {
        if (!this._readOnly) {
            this.checkIfDisposed();
            this._readOnly = new ReadOnlyAbortToken(this);
        }
        return this._readOnly;
    }
    get signal() {
        if (!this._controller) {
            this._controller = new AbortController();
        }
        return this._controller.signal;
    }
    register(listener) {
        this.checkIfDisposed();
        if (listener !== AbortToken.none) {
            this._listeners.push(listener);
        }
    }
    throwIfAborted() {
        this.checkIfDisposed();
        if (this.aborted)
            throw new AbortError();
    }
    abort(reason) {
        var _a;
        if (!this.disposed && !this.aborted) {
            this._abortReason = reason;
            (_a = this._controller) === null || _a === void 0 ? void 0 : _a.abort();
            this._listeners.forEach(async (l) => {
                if (l instanceof Deferred) {
                    l.reject(reason);
                }
                else if (l instanceof Function) {
                    l(reason);
                }
                else {
                    l.abort(reason);
                }
            });
            return true;
        }
        return false;
    }
    /**
     * Attach the promise to abort current token if the promise itself is aborted too
     * @param promiseOrDeferred Promise of Deferred to listen
     */
    attach(abortable) {
        this.checkIfDisposed();
        if (abortable instanceof Promise || abortable instanceof Deferred) {
            abortable.then(null, err => this.abort(err));
        }
        else {
            abortable.register(reason => this.abort(reason));
        }
    }
    dispose() {
        if (this._listeners.length) {
            var reason = new DisposedError("Token disposed");
            this.abort(reason);
            this._listeners.splice(0);
        }
    }
}const IClock = ServiceIdentifier({ namespace: "@aster-js/ioc", name: "IClock", unique: true });
let SystemClock = class SystemClock {
    now() {
        return new Date();
    }
    utcNow() {
        return new Date(Date.now());
    }
};
SystemClock = __decorate([
    ServiceContract(IClock)
], SystemClock);const IConfiguration = ServiceIdentifier({ namespace: "@aster-js/ioc", name: "IConfiguration", unique: true });
let Configuration = class Configuration extends DisposableHost {
    get values() { return this._config; }
    get onDidUpdated() { return this._onDidUpdated.event; }
    constructor(config) {
        super();
        this._config = structuredClone(config);
        this.registerForDispose(this._onDidUpdated = new EventEmitter());
    }
    update(config) {
        for (const [key, value] of Object.entries(config)) {
            Object.assign(this._config, { [key]: structuredClone(config) });
            this._onDidUpdated.emit(key, value);
        }
    }
};
Configuration = __decorate([
    ServiceContract(IConfiguration)
], Configuration);const ILogger = ServiceIdentifier({ namespace: "@aster-js/ioc", name: "ILogger", unique: true });
var LogEvent;
(function (LogEvent) {
    LogEvent.extraValues = Symbol("extraValues");
    LogEvent.template = Symbol("template");
})(LogEvent || (LogEvent = {}));
const ILoggerSink = ServiceIdentifier("ILoggerSink");
let DefaultLogger = class DefaultLogger {
    constructor(_iocModule, _clock, _sinks) {
        this._iocModule = _iocModule;
        this._clock = _clock;
        this._sinks = _sinks;
    }
    log(logLevel, err, templateMessage, ...params) {
        const properties = {};
        const message = templateMessage.replaceAll(/\{([\w]+)\}/gi, (original, key) => {
            if (properties.hasOwnProperty(key)) {
                return properties[key];
            }
            if (params.length) {
                const result = params.shift();
                properties[key] = result;
                return result;
            }
            return original;
        });
        properties[LogEvent.template] = templateMessage;
        if (params.length) {
            properties[LogEvent.extraValues] = params;
        }
        const event = {
            scope: this._iocModule.path,
            time: this._clock.utcNow(),
            logLevel,
            message,
            properties,
            err
        };
        for (const sink of this._sinks)
            sink.log(event);
    }
    trace(templateMessage, ...params) {
        this.log(0 /* LogLevel.trace */, null, templateMessage, ...params);
    }
    debug(templateMessage, ...params) {
        this.log(1 /* LogLevel.debug */, null, templateMessage, ...params);
    }
    info(templateMessage, ...params) {
        this.log(2 /* LogLevel.info */, null, templateMessage, ...params);
    }
    warn(err, templateMessage, ...params) {
        this.log(3 /* LogLevel.warn */, err, templateMessage, ...params);
    }
    error(err, templateMessage, ...params) {
        this.log(4 /* LogLevel.error */, err, templateMessage, ...params);
    }
    critical(err, templateMessage, ...params) {
        this.log(5 /* LogLevel.critical */, err, templateMessage, ...params);
    }
};
DefaultLogger = __decorate([
    ServiceContract(ILogger),
    __param(0, IIoCModule),
    __param(1, IClock),
    __param(2, Many(ILoggerSink))
], DefaultLogger);
const DateFormat = new Intl.DateTimeFormat("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hourCycle: "h24",
    fractionalSecondDigits: 3
});
let ConsoleLoggerSink = class ConsoleLoggerSink {
    constructor(_level) {
        this._level = _level;
    }
    log({ scope, time, logLevel, message, err, properties }) {
        if (this.isEnabled(logLevel)) {
            const formatedTime = DateFormat.format(time);
            const log = `[${formatedTime}] [${scope}] ${message}`;
            const args = [log, properties];
            if (err)
                args.push(err);
            switch (logLevel) {
                case 0 /* LogLevel.trace */:
                    console.trace(...args);
                    break;
                case 1 /* LogLevel.debug */:
                    console.debug(...args);
                    break;
                case 2 /* LogLevel.info */:
                    console.info(...args);
                    break;
                case 3 /* LogLevel.warn */:
                    console.warn(...args);
                    break;
                case 4 /* LogLevel.error */:
                case 5 /* LogLevel.critical */:
                    console.error(...args);
                    break;
                default:
                    console.log(message);
                    break;
            }
        }
    }
    isEnabled(logLevel) {
        return logLevel >= this._level;
    }
};
ConsoleLoggerSink = __decorate([
    ServiceContract(ILoggerSink)
], ConsoleLoggerSink);function addConsoleLogger(level) {
    return this
        .addSystemClock()
        .addSingleton(ConsoleLoggerSink, { baseArgs: [level] })
        .tryAddScoped(DefaultLogger);
}
function addSystemClock() {
    return this.tryAddSingleton(SystemClock);
}
function addConfiguration(config) {
    return this.addSingleton(Configuration, { baseArgs: [config] });
}
Object.assign(ServiceCollection.prototype, {
    addConsoleLogger, addSystemClock, addConfiguration
});function* resolvePathSegments(target) {
    let current = target;
    while (current) {
        yield current.name;
        current = current.parent;
    }
}
class IoCContainer extends DisposableHost {
    get path() { return [...resolvePathSegments(this)].reverse().join("/"); }
    get abortToken() { var _a, _b; return (_b = (_a = this._token) === null || _a === void 0 ? void 0 : _a.readOnly) !== null && _b !== void 0 ? _b : AbortToken.none; }
    get running() { return this._token ? !this._token.aborted : false; }
    get services() { return this._provider; }
    get ready() { return this._ready; }
    get logger() { return this._provider.get(ILogger); }
    constructor(name, _provider, setups) {
        super();
        this.name = name;
        this._provider = _provider;
        this._children = new Map();
        this._ready = new Deferred();
        this._setups = [...setups];
    }
    createChildScope(name) {
        if (this._children.has(name))
            throw new Error(`Duplicate child scope "${name}"`);
        const delayed = new Delayed();
        this._children.set(name, delayed);
        return this.createIoCModuleBuilder(name, delayed);
    }
    async start() {
        var _a, _b;
        if (this._token)
            return false;
        const token = AbortToken.create();
        this._token = token;
        const setups = this._setups.splice(0);
        let idx = 0;
        try {
            const asyncTasks = [];
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug("Starting IoC module with {setupCount} setups and {serviceCount}", setups.length, this.services.size);
            for (; idx < setups.length; idx++) {
                const setup = setups[idx];
                token.throwIfAborted();
                const task = setup.exec(this._provider, token);
                if (setup.execBehavior === IoCModuleSetupExecBehavior.asynchronous) {
                    asyncTasks.push(task);
                }
                else {
                    const taskResult = await task;
                    if (taskResult === IoCModuleSetupResultBehavior.stop)
                        break;
                }
            }
            if (asyncTasks.length !== 0) {
                await this.execAsyncTasks(asyncTasks);
            }
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info("Application successfully started.");
            this._ready.resolve(this);
            return true;
        }
        catch (err) {
            this.handleSetupError(err, idx, setups, token);
            return false;
        }
    }
    handleSetupError(err, taskIdx, setups, token) {
        var _a;
        try {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.critical(err, "Error while executing IoC setup action #{number} of the {count} setups", taskIdx, setups.length);
            this._ready.reject(err);
        }
        finally {
            token.abort(err);
        }
    }
    async execAsyncTasks(asyncTasks) {
        const results = await Promise.allSettled(asyncTasks);
        const rejected = results.filter(r => r.status === "rejected");
        if (rejected.length !== 0) {
            const logger = this.logger;
            if (logger) {
                for (let i = 0; i < rejected.length; i++) {
                    const fault = rejected[i];
                    logger.critical(fault.reason, "Error while executing IoC setup action ({number}/{count})", i + 1, rejected.length);
                }
            }
            throw new AggregateError(rejected.map(r => r.reason), "Error while executing IoC setup action");
        }
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            for (const child of this._children.values()) {
                yield yield __await(yield __await(child.get()));
            }
        });
    }
    dispose() {
        IDisposable.safeDisposeAll(this._children.values());
        IDisposable.safeDispose(this._provider);
        IDisposable.safeDispose(this._token);
    }
}
__decorate([
    Memoize
], IoCContainer.prototype, "path", null);class IoCModuleBuilder extends IoCContainerBuilder {
    constructor(name, _result, _parent, _factory) {
        super(name);
        this._result = _result;
        this._parent = _parent;
        this._factory = _factory;
    }
    createModule(name, provider, setups) {
        const result = this._factory(name, provider, setups, this._parent);
        this._result.set(result);
        return result;
    }
    createServiceProvider(services) {
        return ServiceProvider.create(services, this._parent.services);
    }
}class IoCModule extends IoCContainer {
    get parent() { return this._parent; }
    constructor(name, provider, setupCallbacks, _parent) {
        super(name, provider, setupCallbacks);
        this._parent = _parent;
    }
    createIoCModuleBuilder(name, target) {
        return new IoCModuleBuilder(name, target, this, IoCModule.factory);
    }
    static factory(name, provider, setupCallbacks, parent) {
        return new IoCModule(name, provider, setupCallbacks, parent);
    }
}class IoCKernel extends IoCContainer {
    createIoCModuleBuilder(name, target) {
        return new IoCModuleBuilder(name, target, this, IoCModule.factory);
    }
    static create() {
        return new IoCKernelBuilder("root");
    }
}
class IoCKernelBuilder extends IoCContainerBuilder {
    createModule(name, provider, setups) {
        return new IoCKernel(name, provider, setups);
    }
    createServiceProvider(services) {
        return ServiceProvider.create(services);
    }
    configureDefaultServices(services, _provider) {
        services.addTransient(ServiceAccessor);
    }
}function findRootService(serviceId, module) {
    const all = AllParentServices(serviceId, module, true);
    return Iterables.last(all);
}
function* AllParentServices(serviceId, module, includeSelf) {
    const root = includeSelf ? module : module.parent;
    if (root) {
        for (const parent of getAllParents(root)) {
            const service = parent.services.get(serviceId);
            if (service)
                yield service;
        }
    }
}
/** Returns all parent services for provided module */
function* getAllParents(module) {
    let current = module;
    while (current) {
        yield current;
        current = current.parent;
    }
}function AppServiceId(name) {
    return ServiceIdentifier({ name, namespace: "@aster-js/app", unique: true });
}const IApplicationPart = AppServiceId("IApplicationPart");const configure = Symbol("configure");
var IAppConfigureHandler;
(function (IAppConfigureHandler) {
    function create(callback) {
        class CallbackAppConfigureHandler extends CallbackConfigureHandler {
            constructor() {
                super(callback);
            }
        }
        return CallbackAppConfigureHandler;
    }
    IAppConfigureHandler.create = create;
    function resolve(configHandler) {
        const proto = configHandler.prototype;
        if (proto && configure in proto) {
            return configHandler;
        }
        return IAppConfigureHandler.create(configHandler);
    }
    IAppConfigureHandler.resolve = resolve;
})(IAppConfigureHandler || (IAppConfigureHandler = {}));
class CallbackConfigureHandler {
    constructor(_callback) {
        this._callback = _callback;
    }
    [configure](builder, host) {
        this._callback(builder, host);
    }
}/**
 * Service Id and implementation for the service in charge of handling the application routing
 */
const IRouter = AppServiceId("IRouter");const IRouteParser = AppServiceId("IRouteParser");const IRoutingHandlerInvoker = AppServiceId("IRoutingHandlerInvoker");const IRoutingHandler = AppServiceId("IRoutingHandler");const IRoutingTable = AppServiceId("IRoutingTable");/**
 * Service id and contract to store route data and query data result of navigation of current route configuration.
 *
 * To get part route data (route data registered by part route declarations), use IPartRouteData service.
 */
const IContainerRouteData = AppServiceId("IContainerRouteData");/**
 * Service id and store for route data and query data result of navigation for the part itself.
 *
 * To get current route data (route data registered by current app route declarations), use IContainerRouteData service.
 */
const IPartRouteData = AppServiceId("IPartRouteData");const IRoutingObserver = AppServiceId("IRoutingObserver");const IApplicationPartLifecycle = AppServiceId("IApplicationPartLifecycle");
/** Enumerate all application hooks supported in the lifecycle of any service registered in an ApplicationPart */
var ApplicationPartLifecycleHooks;
(function (ApplicationPartLifecycleHooks) {
    /** Symbol used to identify a method called during setup */
    ApplicationPartLifecycleHooks.setup = Symbol("setup");
    /** Symbol used to identify a method when the part is activated */
    ApplicationPartLifecycleHooks.activated = Symbol("activated");
    /** Symbol used to identify a method when the part is put in background */
    ApplicationPartLifecycleHooks.deactivated = Symbol("deactivated");
    async function invoke(part, hook) {
        const promises = [];
        for (const svc of part.services.getAll(IApplicationPartLifecycle, true)) {
            const callback = svc[hook];
            if (typeof callback === "function") {
                const result = callback.apply(svc);
                promises.push(result);
            }
        }
        const allSettledResult = await Promise.allSettled(promises);
        const errors = [...filterRejectedReasons(allSettledResult)];
        if (errors.length === 0)
            return true;
        const logger = part.services.get(ILogger, true);
        for (const err of errors) {
            logger.error(err, "An error occured while calling lifecycle hook {symbol}", hook.description);
        }
        return false;
    }
    ApplicationPartLifecycleHooks.invoke = invoke;
    function* filterRejectedReasons(results) {
        for (const result of results) {
            if (result.status === "rejected")
                yield result.reason;
        }
    }
    function hasAny(ctor) {
        return ApplicationPartLifecycleHooks.setup in ctor.prototype
            || ApplicationPartLifecycleHooks.activated in ctor.prototype
            || ApplicationPartLifecycleHooks.deactivated in ctor.prototype;
    }
    ApplicationPartLifecycleHooks.hasAny = hasAny;
})(ApplicationPartLifecycleHooks || (ApplicationPartLifecycleHooks = {}));let DefaultNavigationHandler = class DefaultNavigationHandler {
    constructor(_location, _router) {
        this._location = _location;
        this._router = _router;
        this._self = this;
    }
    [ApplicationPartLifecycleHooks.setup]() {
        return Promise.resolve();
    }
    async [ApplicationPartLifecycleHooks.activated]() {
        await this._self._router.eval(this._location.href);
        return Promise.resolve();
    }
    [ApplicationPartLifecycleHooks.deactivated]() {
        return Promise.resolve();
    }
};
DefaultNavigationHandler = __decorate([
    ServiceContract(IApplicationPartLifecycle),
    __param(1, IRouter)
], DefaultNavigationHandler);function on(target, type, callback, options) {
    target.addEventListener(type, callback, options);
    return IDisposable.create(() => {
        target.removeEventListener(type, callback, options);
    });
}let HistoryNavigationHandler = class HistoryNavigationHandler {
    constructor(_location, _eventTarget, _router) {
        this._location = _location;
        this._eventTarget = _eventTarget;
        this._router = _router;
    }
    [ApplicationPartLifecycleHooks.setup]() {
        return Promise.resolve();
    }
    [ApplicationPartLifecycleHooks.activated]() {
        if (typeof this._popstateHandle === "undefined") {
            this._popstateHandle = on(this._eventTarget, "popstate", ev => this.onNavigate(ev));
        }
        return Promise.resolve();
    }
    onNavigate(ev) {
        this._router.eval(this._location.href, ev.state);
    }
    [ApplicationPartLifecycleHooks.deactivated]() {
        IDisposable.safeDispose(this._popstateHandle);
        delete this._popstateHandle;
        return Promise.resolve();
    }
    [Symbol.dispose]() {
        IDisposable.safeDispose(this._popstateHandle);
    }
};
HistoryNavigationHandler = __decorate([
    ServiceContract(IApplicationPartLifecycle),
    __param(2, IRouter)
], HistoryNavigationHandler);const RoutingOptions = AppServiceId("RoutingOptions");
const defaultRoutingOptions = {
    linkTagSelectors: "a",
    assignLocationForUnhandled: true,
    partRouteValueName: "part"
};let HyperlinkNavigationHandler = class HyperlinkNavigationHandler {
    constructor(_options, _router) {
        this._options = _options;
        this._router = _router;
    }
    [ApplicationPartLifecycleHooks.setup]() {
        return Promise.resolve();
    }
    [ApplicationPartLifecycleHooks.activated]() {
        if (typeof this._registration === "undefined") {
            this._registration = on(document.body, "click", ev => this.onRootClick(ev));
        }
        return Promise.resolve();
    }
    [ApplicationPartLifecycleHooks.deactivated]() {
        IDisposable.safeDispose(this._registration);
        delete this._registration;
        return Promise.resolve();
    }
    onRootClick(ev) {
        const anchor = this.findAnchor(ev);
        if (!anchor)
            return;
        const href = anchor.getAttribute("href");
        if (!href)
            return;
        const url = new URL(href, location.href);
        if (location.origin !== url.origin)
            return;
        ev.preventDefault();
        ev.stopPropagation();
        if (location.href === url.href)
            return;
        this.navigate(url, anchor.innerText);
    }
    async navigate(url, title) {
        if (await this._router.eval(url.pathname)) {
            history.pushState({}, title, url);
        }
        else if (!this._options.assignLocationForUnhandled) {
            location.assign(url);
        }
    }
    findAnchor(ev) {
        for (const item of ev.composedPath()) {
            if (item instanceof HTMLElement
                && item.matches(this._options.linkTagSelectors)) {
                return item;
            }
        }
    }
    [Symbol.dispose]() {
        IDisposable.safeDispose(this._registration);
    }
};
HyperlinkNavigationHandler = __decorate([
    ServiceContract(IApplicationPartLifecycle),
    __param(0, Options(RoutingOptions)),
    __param(1, IRouter)
], HyperlinkNavigationHandler);let ActionRoutingHandler = class ActionRoutingHandler {
    constructor(path, _action) {
        this.path = path;
        this._action = _action;
    }
    handle(data, app) {
        const result = this._action({ data, app, handler: this });
        if (result instanceof Promise)
            return result;
        return Promise.resolve();
    }
};
ActionRoutingHandler = __decorate([
    ServiceContract(IRoutingHandler)
], ActionRoutingHandler);let ServiceRoutingHandler = class ServiceRoutingHandler {
    constructor(path, _serviceId, _action) {
        this.path = path;
        this._serviceId = _serviceId;
        this._action = _action;
    }
    handle(data, app) {
        const service = app.services.get(this._serviceId, true);
        const result = this._action(service, data);
        if (result instanceof Promise)
            return result;
        return Promise.resolve();
    }
};
ServiceRoutingHandler = __decorate([
    ServiceContract(IRoutingHandler)
], ServiceRoutingHandler);var ApplicationPartUtils;
(function (ApplicationPartUtils) {
    /**
     * Scan all the downstream hierarchy to return all implementations instance of the specified service.
     * @param svc Service to scan
     * @param includeSelf Include the current service in the scan
     * @param nested Indicate whether or not it should return nested children or only direct children
     */
    function* scanActiveChildren(svc, { includeSelf, nested } = {}) {
        const identity = ServiceIdentity.get(svc);
        asserts.ensure(identity, "Service must have an identity");
        const app = identity.owner.get(IApplicationPart, true);
        const routeData = app.services.get(IPartRouteData, false);
        if (includeSelf && routeData)
            yield [routeData.route, app, svc];
        let { activeChild, activeRoute } = app;
        while (activeRoute && activeChild) {
            for (const found of activeChild.services.getAll(identity.desc.serviceId, true)) {
                yield [activeRoute, activeChild, found];
            }
            if (!nested)
                break;
            activeChild = activeChild.activeChild;
            activeRoute = activeChild === null || activeChild === void 0 ? void 0 : activeChild.activeRoute;
        }
    }
    ApplicationPartUtils.scanActiveChildren = scanActiveChildren;
})(ApplicationPartUtils || (ApplicationPartUtils = {}));var RoutingConstants;
(function (RoutingConstants) {
    RoutingConstants.RELATIVE_URL_CHAR = ".";
    RoutingConstants.RELATIVE_CHAR = "~";
    RoutingConstants.SEARCH_CHAR = "?";
})(RoutingConstants || (RoutingConstants = {}));const SEGMENT_SEPARATOR = "/";
/**
 * Helper class for working with URL paths.
 */
class Path {
    /**
     * Gets the count of segments in current path.
     */
    get length() { return this._segments.length; }
    /**
     * Gets whether the current path is relative.
     */
    get relative() { var _a; return (_a = this._relative) !== null && _a !== void 0 ? _a : false; }
    constructor(_segments, _relative) {
        this._segments = _segments;
        this._relative = _relative;
    }
    /**
     * Returns the segment at the specified index.
     * @param idx Index to get the segment at.
     */
    getAt(idx) {
        return this._segments[idx];
    }
    startsWith(pathOrSegments, options) {
        const path = pathOrSegments instanceof Path
            ? pathOrSegments
            : Path.parse(pathOrSegments, options);
        if (path.length > this.length)
            return false;
        return path._segments.every((segment, idx) => segment === this._segments[idx]);
    }
    /**
     * Returns a slice of current path.
     * @param start Offset to start the slice at.
     * @param end Last index to include in the slice.
     */
    slice(start, end) {
        return new Path(this._segments.slice(start, end));
    }
    combine(path, options) {
        if (path instanceof Path)
            return new Path([...this, ...path], this._relative);
        return new Path([...this, ...Path.parse(path, options)], this._relative);
    }
    toString() {
        return Path.join(this._segments);
    }
    equals(other) {
        return this._segments.length === other._segments.length
            && this._segments.every((segment, idx) => segment === other._segments[idx]);
    }
    [Symbol.iterator]() {
        return this._segments[Symbol.iterator]();
    }
    /** Parses the specified path into a Path instance. */
    static parse(path, options) {
        const segments = Path.split(path, options === null || options === void 0 ? void 0 : options.separator);
        if (segments.length === 0)
            return Path.empty;
        if (segments[0] === ((options === null || options === void 0 ? void 0 : options.relativeIndicator) || RoutingConstants.RELATIVE_URL_CHAR)) {
            return new Path(segments.slice(1), true);
        }
        return new Path(segments);
    }
    /** Trims the specified path by removing starting and ending separators. */
    static trim(path) {
        const offset = path.startsWith(SEGMENT_SEPARATOR) ? 1 : 0;
        const length = path.endsWith(SEGMENT_SEPARATOR) ? path.length - 1 : path.length;
        return path.substring(offset, length);
    }
    /** Splits the specified path into segments. */
    static split(path, separator) {
        return path
            .split(separator || SEGMENT_SEPARATOR)
            .filter(Boolean)
            .map(decodeURIComponent);
    }
    /** Joins the specified segments into a path. */
    static join(segments) {
        if (segments.length === 0)
            return SEGMENT_SEPARATOR;
        const builder = Query(segments)
            .map(x => this.trim(x));
        return SEGMENT_SEPARATOR + builder.toArray().join(SEGMENT_SEPARATOR) + SEGMENT_SEPARATOR;
    }
    /** Returns whether the specified path is empty. */
    static isEmpty(path) {
        return !path || path === SEGMENT_SEPARATOR;
    }
}
/**
 * An empty path.
 */
Path.empty = new Path([]);class RouteResolutionCursor {
    get remaining() { return this._segments.length - this._next; }
    get relative() { return this._relative; }
    get remainingPath() { return Path.join(this._segments.slice(this._next)); }
    get sourcePath() { return Path.join(this._segments); }
    constructor(segments, _relative) {
        this._relative = _relative;
        this._next = 0;
        this._segments = [...segments];
    }
    peek(offset = 0) {
        return this._segments[this._next + offset];
    }
    shift() {
        if (this._segments.length <= this._next)
            return;
        const result = this._segments[this._next];
        this._next++;
        return result;
    }
    *[Symbol.iterator]() {
        yield* this._segments.slice(this._next);
    }
    toString() {
        return Path.join(this._segments.slice(this._next));
    }
    static read(url, options) {
        const path = Path.parse(url, options);
        return new RouteResolutionCursor(path, path.relative);
    }
}var SearchValues;
(function (SearchValues) {
    SearchValues.empty = Object.freeze({});
    /** Parse and map a query search into a QueryValues bag */
    function parse(search) {
        const result = {};
        const searchParams = new URLSearchParams(search);
        for (const [key, value] of searchParams) {
            if (Reflect.has(result, key)) {
                const current = result[key];
                if (Array.isArray(current)) {
                    current.push(value);
                }
                else {
                    result[key] = [current, value];
                }
            }
            else {
                result[key] = value;
            }
        }
        return Object.freeze(result);
    }
    SearchValues.parse = parse;
    function toString(query, sort) {
        const search = new URLSearchParams();
        const entries = Object.entries(query);
        for (const [key, value] of entries) {
            if (Array.isArray(value)) {
                for (const v of value) {
                    search.append(key, v);
                }
            }
            else {
                search.append(key, value);
            }
        }
        if (search)
            search.sort();
        return search.toString();
    }
    SearchValues.toString = toString;
    function areEquals(first, second) {
        const firstEntries = Object.entries(first);
        const secondKeys = Object.keys(second);
        if (firstEntries.length !== secondKeys.length)
            return false;
        if (firstEntries.length === 0)
            return true;
        for (const [key, firstValue] of firstEntries) {
            const secondValue = second[key];
            if (typeof firstValue !== typeof secondValue)
                return false;
            if (Array.isArray(firstValue)) {
                if (!Array.isArray(secondValue) || firstValue.length !== secondValue.length)
                    return false;
                const firstIndex = new Set(firstValue);
                for (const secondItem of secondValue) {
                    if (!firstIndex.has(secondItem))
                        return false;
                }
            }
            else {
                if (Array.isArray(secondValue))
                    return false;
                if (firstValue !== secondValue)
                    return false;
            }
        }
        return true;
    }
    SearchValues.areEquals = areEquals;
})(SearchValues || (SearchValues = {}));var UrlValues;
(function (UrlValues) {
    /** Create a new ParamValues by merging RouteValues and QueryValues */
    function create(values, query) {
        return Object.assign({}, values, query);
    }
    UrlValues.create = create;
})(UrlValues || (UrlValues = {}));class RelativeRouteSegment {
    constructor() { }
    match(segment) { return true; }
    read(ctx, values) {
        const current = ctx.peek();
        if (current !== RoutingConstants.RELATIVE_CHAR) {
            throw new Error(`Invalid token: expected segment to be a "~" symbol but current segment is equal to "${current}"`);
        }
        ctx.shift();
        return null;
    }
    resolve(values, consume) {
        return null;
    }
    toString() {
        return RoutingConstants.RELATIVE_CHAR;
    }
    static isRelative(segment) {
        return segment === RoutingConstants.RELATIVE_CHAR;
    }
}
RelativeRouteSegment.instance = new RelativeRouteSegment();const WILDCARD_CHAR = "*";
class WildcardRouteSegment {
    constructor() { }
    match(segment) { return segment === WILDCARD_CHAR; }
    read(ctx, values) {
        const current = ctx.peek();
        if (current !== WILDCARD_CHAR) {
            throw new Error(`Invalid token: expected segment to be a wildcard symbol but current segment is equal to "${current}"`);
        }
        ctx.shift();
        return null;
    }
    resolve(values, consume) {
        return null;
    }
    toString() {
        return WILDCARD_CHAR;
    }
    static isWildcard(segment) {
        return segment === WILDCARD_CHAR;
    }
}
WildcardRouteSegment.instance = new WildcardRouteSegment();class StaticRouteSegment {
    get segment() { return this._segment; }
    constructor(_segment) {
        this._segment = _segment;
    }
    match(segment) {
        return segment === this._segment;
    }
    read(ctx, values) {
        const current = ctx.peek();
        if (current !== this._segment) {
            throw new Error(`Invalid token: expected segment equals to "${this._segment}" but current segment is equal to "${current}"`);
        }
        ctx.shift();
        return this._segment;
    }
    resolve(values, consume) {
        return this._segment;
    }
    toString() {
        return this._segment;
    }
}class ValueRouteSegment {
    get name() { return this._name; }
    get optional() { return this._optional; }
    get defaultValue() { return this._defaultValue; }
    get defaultValueString() { return this._converter.convertBack(this._defaultValue); }
    constructor(_name, _optional, _defaultValue, _converter, _validator) {
        this._name = _name;
        this._optional = _optional;
        this._defaultValue = _defaultValue;
        this._converter = _converter;
        this._validator = _validator;
    }
    match(segment) {
        var _a, _b;
        if (typeof segment === "undefined") {
            return this._optional;
        }
        return this._converter.canConvert(segment) && ((_b = (_a = this._validator) === null || _a === void 0 ? void 0 : _a.validate(segment)) !== null && _b !== void 0 ? _b : true);
    }
    read(ctx, values) {
        const value = ctx.shift();
        if (typeof value !== "undefined" && value !== null) {
            values[this._name] = this._converter.convert(value);
            return String(value);
        }
        if (this._defaultValue !== null) {
            values[this._name] = this._defaultValue;
            return this.defaultValueString;
        }
        return null;
    }
    resolve(values, consume) {
        if (Reflect.has(values, this._name)) {
            const value = values[this._name];
            if (consume)
                delete values[this._name];
            return this._converter.convertBack(value);
        }
        if (!this._optional || this._defaultValue === null) {
            throw new Error(`Missing value for route value "${this._name}"`);
        }
        return this.defaultValueString;
    }
    toString() {
        if (!this._toStringCache) {
            const builder = [this._name];
            if (this._optional)
                builder.push("?");
            if (this._defaultValue !== null)
                builder.push(`:${this.defaultValueString}`);
            this._toStringCache = `{${builder.join("")}}`;
        }
        return this._toStringCache;
    }
}
__decorate([
    cacheResult()
], ValueRouteSegment.prototype, "defaultValueString", null);/** Represents a route. */
class Route {
    get wildcard() { var _a; return (_a = this._wildcard) !== null && _a !== void 0 ? _a : false; }
    get relative() { var _a; return (_a = this._relative) !== null && _a !== void 0 ? _a : false; }
    constructor(segments) {
        const array = [...segments];
        this._toStringCache = this.buildToString(array);
        if (array.length) {
            if (array[array.length - 1] === WildcardRouteSegment.instance) {
                array.pop();
                this._wildcard = true;
            }
            if (array.length && array[0] === RelativeRouteSegment.instance) {
                array.shift();
                this._relative = true;
            }
        }
        this._segments = array;
    }
    match(ctx) {
        if (!this._wildcard && ctx.remaining > this._segments.length)
            return false;
        if (this._relative && !ctx.relative)
            return false;
        for (let idx = 0; idx < this._segments.length; idx++) {
            const value = ctx.peek(idx);
            if (!this._segments[idx].match(value)) {
                return false;
            }
        }
        return true;
    }
    getRouteValues(ctx) {
        const values = {};
        const path = [];
        for (let i = 0; i < this._segments.length; i++) {
            const consumedPath = this._segments[i].read(ctx, values);
            if (consumedPath)
                path.push(consumedPath);
        }
        return [Path.join(path), values];
    }
    resolve(values, consume) {
        const segments = this.resolveSegments(values, consume);
        return Path.join([...segments]);
    }
    *resolveSegments(values, consume) {
        for (const segment of this._segments) {
            const resolved = segment.resolve(values, consume);
            if (resolved)
                yield resolved;
        }
    }
    *[Symbol.iterator]() {
        yield* this._segments;
    }
    toString() {
        return this._toStringCache;
    }
    buildToString(segments) {
        const strSegments = segments.map(segment => segment.toString());
        return Path.join(strSegments);
    }
}
Route.empty = new Route([]);var RouteData;
(function (RouteData) {
    RouteData.empty = Object.freeze({ path: "", route: Route.empty, values: {}, query: {} });
    function create(path, route, defaultRouteValues, routeValues, searchValues) {
        const mergedValues = Object.assign(Object.assign({}, defaultRouteValues), routeValues);
        return { path, route, values: mergedValues, query: searchValues };
    }
    RouteData.create = create;
})(RouteData || (RouteData = {}));let ContainerRouteData = class ContainerRouteData {
    get path() { return this._current.path; }
    get route() { return this._current.route; }
    get values() { return this._current.values; }
    get query() { return this._current.query; }
    constructor() {
        this._previous = RouteData.empty;
        this._current = RouteData.empty;
    }
    onRoutingDidBegin(handler, routeData, application) {
        this._previous = this._current;
        this._current = routeData;
        return Promise.resolve();
    }
    onRoutingDidComplete(handler, routeData, application) {
        this._previous = RouteData.empty;
        return Promise.resolve();
    }
    onRoutingDidFail(handler, routeData, application) {
        this._current = this._previous;
        return Promise.resolve();
    }
};
ContainerRouteData = __decorate([
    ServiceContract(IContainerRouteData)
], ContainerRouteData);
let ContainerRouteDataRoutingObserverFactory = class ContainerRouteDataRoutingObserverFactory {
    static get targetType() { return ContainerRouteData; }
    constructor(_serviceProvider) {
        this._serviceProvider = _serviceProvider;
    }
    create() {
        return this._serviceProvider.get(IContainerRouteData);
    }
};
ContainerRouteDataRoutingObserverFactory = __decorate([
    ServiceFactory(IRoutingObserver),
    __param(0, IServiceProvider)
], ContainerRouteDataRoutingObserverFactory);let DefaultRouter = class DefaultRouter {
    constructor(_routingTable, _application, _handlerInvoker, _logger) {
        this._routingTable = _routingTable;
        this._application = _application;
        this._handlerInvoker = _handlerInvoker;
        this._logger = _logger;
    }
    async eval(url, defaults = {}) {
        this._logger.debug(`Evaluating route "{url}"`, url);
        try {
            // Relative path
            if (url.startsWith(RoutingConstants.RELATIVE_CHAR)) {
                return await this.evalRelativePath(url, defaults);
            }
            // Retrieve the root router to handle not relative path
            const root = findRootService(IRouter, this._application);
            if (root && root !== this) {
                return await root.eval(url, defaults);
            }
            // Non relative path (root router context)
            // This url may be relative or not
            const finalUrl = new URL(url, location.origin);
            const path = Path.parse(finalUrl.pathname);
            const search = SearchValues.parse(finalUrl.search);
            return await this.evalCore(path, search, defaults);
        }
        finally {
            this._logger.debug(`Route "{url}" evaluation completed`, url);
        }
    }
    evalRelativePath(relativeUrl, defaults) {
        const idx = relativeUrl.indexOf(RoutingConstants.SEARCH_CHAR);
        if (idx === -1) {
            const path = Path.parse(relativeUrl, { relativeIndicator: RoutingConstants.RELATIVE_CHAR });
            return this.evalCore(path, SearchValues.empty, defaults);
        }
        const rawPath = relativeUrl.substring(0, idx);
        const rawSearch = relativeUrl.substring(idx + 1);
        const path = Path.parse(rawPath, { relativeIndicator: RoutingConstants.RELATIVE_CHAR });
        const search = SearchValues.parse(rawSearch);
        return this.evalCore(path, search, defaults);
    }
    evalCore(path, search, defaults) {
        if (this._current && this._current[0].equals(path) && SearchValues.areEquals(this._current[1], search)) {
            return Promise.resolve(true);
        }
        this._current = [path, search];
        const ctx = new RouteResolutionCursor(path, path.relative);
        return this.handleCore(ctx, defaults, search);
    }
    async handle(ctx, values, search) {
        ctx = new RouteResolutionCursor(ctx, true);
        return this.handleCore(ctx, values, search);
    }
    async handleCore(ctx, values, search) {
        const routeHandler = await this.resolveHandler(ctx);
        if (!routeHandler) {
            this._logger.warn(null, `No match found for the remaining route path: {relativeUrl}`, ctx.remainingPath, ...this._routingTable.getPaths());
            return false;
        }
        await this.invokeHandler(...routeHandler, ctx, values, search);
        return true;
    }
    /**
     * Returns a handler that matches the current route
     * @param ctx The route resolution context
     */
    async resolveHandler(ctx) {
        if (ctx.relative) {
            return Query(this._routingTable.getHandlers())
                .findFirst(([route]) => route.match(ctx));
        }
        const children = ApplicationPartUtils.scanActiveChildren(this._routingTable, { includeSelf: true, nested: true });
        return Query(children)
            .flatMap(([, , x]) => x.getHandlers())
            .findFirst(([route]) => route.match(ctx));
    }
    async invokeHandler(route, handler, ctx, values, query) {
        const [path, localValues] = route.getRouteValues(ctx);
        const routeData = RouteData.create(path, route, values, localValues, query);
        await this._handlerInvoker.invoke(handler, ctx, routeData);
        const activeChildren = [...ApplicationPartUtils.scanActiveChildren(this, { includeSelf: false, nested: false })];
        if (activeChildren.length !== 0) {
            let flag = true;
            for (const [activeRoute, activePart, child] of activeChildren) {
                if (activeRoute !== route) {
                    this._application.desactivate(activePart.name);
                }
                else if (flag && await child.handle(ctx, routeData.values, query)) {
                    flag = false;
                    this._logger.debug("Child router handled the remaining route {path}", ctx.toString());
                }
                else if (this._application.activeChild === activePart) {
                    this._application.desactivate(activePart.name);
                }
            }
            if (flag && ctx.remaining !== 0) {
                this._logger.warn(null, "No match found for the remaining route path: {relativeUrl}", ctx.remainingPath);
            }
        }
        else if (ctx.remaining !== 0) {
            this._logger.warn(null, "No child to handle the remaining route path: {relativeUrl}", ctx.remainingPath);
        }
        else {
            this._logger.debug("Routing completed successfully.");
        }
    }
};
DefaultRouter = __decorate([
    ServiceContract(IRouter),
    __param(0, IRoutingTable),
    __param(1, IApplicationPart),
    __param(2, IRoutingHandlerInvoker),
    __param(3, ILogger)
], DefaultRouter);const IUrlValueValidatorFactory = AppServiceId("IUrlValueValidatorFactory");const IUrlValueConverterFactory = AppServiceId("IUrlValueConverterFactory");var AnySegmentArguments;
(function (AnySegmentArguments) {
    AnySegmentArguments.OPEN_CHAR = "<";
    AnySegmentArguments.CLOSE_CHAR = ">";
    const EMPTY_EXPRESSION = "<>";
    const RANGE_EXPRESSION = "..";
    const ENUM_SEPARATOR_CHAR = "|";
    const REGEX_START_CHAR = "^";
    const REGEX_END_CHAR = "$";
    function parse(expression) {
        if (!expression || expression === EMPTY_EXPRESSION)
            return ["none"];
        if (!expression.startsWith(AnySegmentArguments.OPEN_CHAR) || !expression.endsWith(AnySegmentArguments.CLOSE_CHAR)) {
            throw new Error("Invalid route format: Segment arguments must be surrounded with '<args>'.");
        }
        const argsExpression = expression.substring(1, expression.length - 1);
        if (argsExpression.indexOf(RANGE_EXPRESSION) !== -1) {
            const [min, max, ...rest] = argsExpression.split("..");
            if (rest.length)
                throw new Error("Invalid route format: Range dots '..' must only appear once per segment.");
            return ["range", min, max];
        }
        if (argsExpression.startsWith(REGEX_START_CHAR) && argsExpression.endsWith(REGEX_END_CHAR)) {
            return [
                "regex",
                argsExpression
            ];
        }
        const enumValues = argsExpression.split(ENUM_SEPARATOR_CHAR);
        return enumValues.length === 0 ? ["none"] : ["enum", ...enumValues];
    }
    AnySegmentArguments.parse = parse;
})(AnySegmentArguments || (AnySegmentArguments = {}));const ASSIGN_CHAR = ":";
const NULLABLE_CHAR = "?";
let DefaultRouteParser = class DefaultRouteParser {
    constructor(_converterFactory, _validatorFactory) {
        this._converterFactory = _converterFactory;
        this._validatorFactory = _validatorFactory;
    }
    *parse(route) {
        if (Path.isEmpty(route))
            return;
        const path = Path.parse(route);
        for (let i = 0; i < path.length; i++) {
            const segment = path.getAt(i);
            asserts.defined(segment);
            if (RelativeRouteSegment.isRelative(segment)) {
                if (i !== 0) {
                    throw new Error(`Relative symbol "${segment}" can only appear at index 0 but appear at ${i} in route "${route}"`);
                }
                yield RelativeRouteSegment.instance;
            }
            else if (WildcardRouteSegment.isWildcard(segment)) {
                if ((i + 1) < path.length) {
                    throw new Error("Wildcard segment must be the last segment in the route");
                }
                yield WildcardRouteSegment.instance;
            }
            else if (segment.startsWith(ASSIGN_CHAR)) {
                yield this.parseDynamicSegment(segment.substring(1));
            }
            else {
                yield new StaticRouteSegment(segment);
            }
        }
    }
    /**
     * Currently supported dynamic segment formats:
     * - String Enum: /:name<one|two|three>?one/
     * - Boolean:
     *      - /:!condition<true|false>?true/
     *      - /:!condition<yes|no>?yes/
     * - Number with optional range:
     *      - /:+size<..50>?44/
     *      - /:+page<1..>?1/
     *      - /:+page<1..100>?1/
     * - Regex on any type: /:name<^[\w]$>?111/
     */
    parseDynamicSegment(segment) {
        let argsExpression = "";
        let defaultExpression = "";
        let optional = false;
        let defaultValue = null;
        const argsIdx = segment.indexOf(AnySegmentArguments.OPEN_CHAR);
        const nullableIdx = segment.lastIndexOf(NULLABLE_CHAR);
        const nameEndIdx = argsIdx !== -1 ? argsIdx : nullableIdx !== -1 ? nullableIdx : -1;
        let name = nameEndIdx === -1 ? segment : segment.substring(0, nameEndIdx);
        const argsEndIdx = segment.lastIndexOf(AnySegmentArguments.CLOSE_CHAR);
        if (argsIdx !== -1) {
            if (argsEndIdx === -1)
                throw new Error("Invalid route format: Segment arguments must be surrounded with '<args>', closing one missing.");
            argsExpression = segment.substring(argsIdx, argsEndIdx + 1);
        }
        else if (argsEndIdx !== -1) {
            throw new Error("Invalid route format: Segment arguments must be surrounded with '<args>', opening one missing.");
        }
        if (nullableIdx !== -1 && nullableIdx > argsEndIdx) {
            defaultExpression = segment.slice(nullableIdx);
        }
        const args = AnySegmentArguments.parse(argsExpression);
        const validator = this._validatorFactory.create(args);
        // Resolve converter and remove type indicator
        const indicator = name.charAt(0);
        let converter = this._converterFactory.create(indicator, args);
        if (converter !== null) {
            name = name.substring(1);
        }
        else {
            converter = this._converterFactory.getDefaultConverter();
        }
        // Nullable will occur after validator
        if (defaultExpression) {
            optional = true;
            if (defaultExpression !== NULLABLE_CHAR) {
                defaultValue = converter.convert(defaultExpression.substring(1));
            }
        }
        return new ValueRouteSegment(name, optional, defaultValue, converter, validator);
    }
};
DefaultRouteParser = __decorate([
    ServiceContract(IRouteParser),
    __param(0, IUrlValueConverterFactory),
    __param(1, IUrlValueValidatorFactory)
], DefaultRouteParser);let DefaultRoutingHandlerInvoker = class DefaultRoutingHandlerInvoker {
    constructor(_application, _observers, _logger) {
        this._application = _application;
        this._observers = _observers;
        this._logger = _logger;
    }
    async invoke(handler, { sourcePath, remainingPath: relativePath }, routeData) {
        this.onDidUrlMatch(handler, sourcePath, relativePath, routeData);
        try {
            await Promise.allSettled(this._observers.map(x => x.onRoutingDidBegin(handler, routeData, this._application)));
            await handler.handle(routeData, this._application);
            await Promise.allSettled(this._observers.map(x => x.onRoutingDidComplete(handler, routeData, this._application)));
        }
        catch (err) {
            await Promise.allSettled(this._observers.map(x => x.onRoutingDidFail(handler, routeData, this._application)));
            this.onHandlerError(err, handler, sourcePath, relativePath, routeData);
        }
    }
    onDidUrlMatch(handler, sourcePath, relativePath, routeData) {
        if (sourcePath !== relativePath) {
            this._logger.info(`Routing match relative path "{relativePath}" in path "{path}" with route "{routePath}"`, relativePath, sourcePath, handler.path, routeData);
        }
        else {
            this._logger.info(`Routing match path "{path}" with route "{routePath}"`, sourcePath, handler.path, routeData);
        }
    }
    onHandlerError(err, handler, sourcePath, relativePath, routeData) {
        if (sourcePath !== relativePath) {
            this._logger.error(err, `Error handled during route handler invocation on relative path "{relativePath}" in path "{path}" with route "{routePath}"`, relativePath, sourcePath, handler.path, routeData);
        }
        else {
            this._logger.error(err, `Error handled during route handler invocation on path "{path}" with route "{routePath}"`, sourcePath, handler.path, routeData);
        }
    }
};
DefaultRoutingHandlerInvoker = __decorate([
    ServiceContract(IRoutingHandlerInvoker),
    __param(0, IApplicationPart),
    __param(1, Many(IRoutingObserver)),
    __param(2, ILogger)
], DefaultRoutingHandlerInvoker);let DefaultRoutingTable = class DefaultRoutingTable {
    constructor(parser, handlers) {
        this._handlers = handlers.map(x => [new Route(parser.parse(x.path)), x]);
    }
    *getPaths() {
        for (const [, handler] of this._handlers) {
            yield handler.path;
        }
    }
    *getHandlers() {
        yield* this._handlers;
    }
};
DefaultRoutingTable = __decorate([
    ServiceContract(IRoutingTable),
    __param(0, IRouteParser),
    __param(1, Many(IRoutingHandler))
], DefaultRoutingTable);let PartRouteData = class PartRouteData {
    get path() { var _a, _b; return (_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : ""; }
    get route() { var _a, _b; return (_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a.route) !== null && _b !== void 0 ? _b : Route.empty; }
    get values() { var _a, _b; return (_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a.values) !== null && _b !== void 0 ? _b : {}; }
    get query() { var _a, _b; return (_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a.query) !== null && _b !== void 0 ? _b : {}; }
    constructor(part) {
        var _a;
        this._parent = (_a = part.parent) === null || _a === void 0 ? void 0 : _a.services.get(IContainerRouteData);
    }
};
PartRouteData = __decorate([
    ServiceContract(IPartRouteData),
    __param(0, IApplicationPart)
], PartRouteData);let PartLoaderRoutingHandler = class PartLoaderRoutingHandler {
    constructor(path, _configHandler, _options) {
        this.path = path;
        this._configHandler = _configHandler;
        this._options = _options;
    }
    async handle(data, app) {
        const appName = data.values[this._options.partRouteValueName];
        if (typeof appName !== "string")
            throw new Error(`Missing route value named 'part'`);
        await app.load(appName, data.route, this._configHandler);
    }
};
PartLoaderRoutingHandler = __decorate([
    ServiceContract(IRoutingHandler),
    __param(2, Options(RoutingOptions))
], PartLoaderRoutingHandler);const ControllerRoutingHandlerTag = Tag.lazy("routes", () => []);
Tag.lazy("route args", () => new Lookup());class SetupIoCContainerBuilder {
    constructor(_appBuilder, _iocBuilder) {
        this._appBuilder = _appBuilder;
        this._iocBuilder = _iocBuilder;
    }
    continueWithoutAwaiting() {
        this._iocBuilder.continueWithoutAwaiting();
        return this._appBuilder;
    }
    catch(errorHandler) {
        this._iocBuilder.catch(errorHandler);
        return this._appBuilder;
    }
    use(action) {
        return this._appBuilder.use(action);
    }
    addPart(path, configHandler) {
        return this._appBuilder.addPart(path, configHandler);
    }
    addController(ctor) {
        return this._appBuilder.addController(ctor);
    }
    addAction(path, actionOrServiceId, action) {
        return this._appBuilder.addAction(path, actionOrServiceId, action);
    }
    setup(serviceIdOrCtor, action, required = true) {
        return this._appBuilder.setup(serviceIdOrCtor, action, required);
    }
    setupMany(serviceIdOrCtor, action, currentScopeOnly = true) {
        return this._appBuilder.setupMany(serviceIdOrCtor, action, currentScopeOnly);
    }
    configure(action) {
        return this._appBuilder.configure(action);
    }
    build() {
        return this._appBuilder.build();
    }
}class ApplicationPartBuilder {
    constructor(partName, _source, _result) {
        this._source = _source;
        this._result = _result;
        this._innerBuilder = _source.createChildScope(partName);
    }
    addPart(path, configHandler) {
        const ctor = IAppConfigureHandler.resolve(configHandler);
        this.configure(x => x.addScoped(PartLoaderRoutingHandler, {
            baseArgs: [path, ctor],
            scope: ServiceScope.container
        }));
        return this;
    }
    addController(ctor) {
        const handlers = ControllerRoutingHandlerTag.get(ctor.prototype);
        this.configure(x => {
            const serviceId = resolveServiceId(ctor);
            x.addScoped(serviceId, ctor, { scope: ServiceScope.container });
            for (const handler of handlers) {
                x.addScoped(IRoutingHandler, handler, { scope: ServiceScope.container });
            }
        });
        return this;
    }
    addAction(path, actionOrServiceId, action) {
        if (ServiceIdentifier.is(actionOrServiceId)) {
            this.configure(x => x.addScoped(ServiceRoutingHandler, {
                baseArgs: [path, actionOrServiceId, action],
                scope: ServiceScope.container
            }));
        }
        else {
            this.configure(x => x.addScoped(ActionRoutingHandler, {
                baseArgs: [path, actionOrServiceId],
                scope: ServiceScope.container
            }));
        }
        return this;
    }
    configure(action) {
        this._innerBuilder.configure(action);
        return this;
    }
    use(action) {
        const iocBuilder = this._innerBuilder.use(action);
        return new SetupIoCContainerBuilder(this, iocBuilder);
    }
    setupMany(ctor, action, currentScopeOnly) {
        const iocBuilder = this._innerBuilder.setupMany(ctor, action, currentScopeOnly);
        return new SetupIoCContainerBuilder(this, iocBuilder);
    }
    setup(ctor, action, required) {
        const iocBuilder = this._innerBuilder.setup(ctor, action, required);
        return new SetupIoCContainerBuilder(this, iocBuilder);
    }
    build() {
        const part = this.createApplicationPart(this._source, this._innerBuilder);
        this._result.set(part);
        return part;
    }
}let ApplicationPartLifecycleWrapper = class ApplicationPartLifecycleWrapper {
    constructor(_descriptor, _logger, serviceProvider) {
        this._descriptor = _descriptor;
        this._logger = _logger;
        this._instance = serviceProvider.get(_descriptor, true);
    }
    [ApplicationPartLifecycleHooks.setup]() {
        return this.invokeLifecycleMethod(ApplicationPartLifecycleHooks.setup);
    }
    [ApplicationPartLifecycleHooks.activated]() {
        return this.invokeLifecycleMethod(ApplicationPartLifecycleHooks.activated);
    }
    [ApplicationPartLifecycleHooks.deactivated]() {
        return this.invokeLifecycleMethod(ApplicationPartLifecycleHooks.deactivated);
    }
    async invokeLifecycleMethod(hook) {
        this._logger.debug(`Calling hook "{hook}" on service {serviceId}`, hook.description, this._descriptor.serviceId);
        const callback = this._instance[hook];
        if (callback)
            await callback.apply(this._instance);
    }
};
ApplicationPartLifecycleWrapper = __decorate([
    ServiceContract(IApplicationPartLifecycle),
    __param(1, ILogger),
    __param(2, IServiceProvider)
], ApplicationPartLifecycleWrapper);const INavigationService = AppServiceId("INavigationService");let DefaultNavigationService = class DefaultNavigationService {
    constructor(_router, _application) {
        this._router = _router;
        this._application = _application;
    }
    async navigate(relativeUrl, replace = false) {
        const isRelative = relativeUrl.startsWith(RoutingConstants.RELATIVE_CHAR);
        const coercedUrl = isRelative ? RoutingConstants.RELATIVE_URL_CHAR + relativeUrl.substring(1) : relativeUrl;
        const baseAddress = this.getBaseAddress(isRelative);
        const url = new URL(coercedUrl, baseAddress);
        if (replace) {
            history.replaceState({}, "", url);
        }
        else {
            history.pushState({}, "", url);
        }
        await this._router.eval(relativeUrl);
    }
    getBaseAddress(isRelative) {
        if (isRelative) {
            const all = AllParentServices(IContainerRouteData, this._application, false);
            const segments = Query(all)
                .map(x => x.path)
                .toArray()
                .reverse();
            return new URL(Path.join(segments), location.origin);
        }
        return new URL(location.href);
    }
};
DefaultNavigationService = __decorate([
    ServiceContract(INavigationService),
    __param(0, IRouter),
    __param(1, IApplicationPart)
], DefaultNavigationService);class UrlStringValueConverter {
    canConvert(value) {
        return true;
    }
    convert(value) {
        return decodeURIComponent(value);
    }
    convertBack(value) {
        return encodeURIComponent(value);
    }
}
class UrlBooleanValueConverter {
    constructor(trueValue, falseValue) {
        this._trueValue = encodeURIComponent(trueValue);
        this._falseValue = encodeURIComponent(falseValue);
    }
    canConvert(value) {
        return this._trueValue === value || this._falseValue === value;
    }
    convert(value) {
        return value === this._trueValue;
    }
    convertBack(value) {
        return value ? this._trueValue : this._falseValue;
    }
}
class UrlNumberValueConverter {
    canConvert(value) {
        return isNaN(+value) === false;
    }
    convert(value) {
        return parseFloat(value);
    }
    convertBack(value) {
        return String(value);
    }
}const STRING_INDICATOR_CHAR = "$";
const NUMBER_INDICATOR_CHAR = "+";
const BOOL_INDICATOR_CHAR = "!";
let DefaultUrlValueConverterFactory = class DefaultUrlValueConverterFactory {
    constructor() {
        this._defaultConverter = new UrlStringValueConverter();
    }
    getDefaultConverter() {
        return this._defaultConverter;
    }
    create(indicator, [argType, ...args]) {
        switch (indicator) {
            case STRING_INDICATOR_CHAR:
                return this._defaultConverter;
            case BOOL_INDICATOR_CHAR:
                if (argType === "enum") {
                    if (args.length !== 2) {
                        throw new Error(`Invalid route format: Only 2 possible values must be provided for booleans <true|false> but provided: ${args.join("|")} `);
                    }
                    return new UrlBooleanValueConverter(args[0], args[1]);
                }
                return new UrlBooleanValueConverter("true", "false");
            case NUMBER_INDICATOR_CHAR:
                return new UrlNumberValueConverter();
            default: return null;
        }
    }
};
DefaultUrlValueConverterFactory = __decorate([
    ServiceContract(IUrlValueConverterFactory)
], DefaultUrlValueConverterFactory);class UrlRangeValidator {
    constructor([, rawMin, rawMax]) {
        const min = parseFloat(rawMin);
        const max = parseFloat(rawMax);
        this._min = isNaN(min) ? Number.MIN_SAFE_INTEGER : min;
        this._max = isNaN(max) ? Number.MAX_SAFE_INTEGER : max;
    }
    validate(value) {
        const num = parseFloat(value);
        return num >= this._min && num <= this._max;
    }
}
class UrlRegexValidator {
    constructor([, regex]) {
        this._regex = new RegExp(regex);
    }
    validate(value) {
        return this._regex.test(value);
    }
}
class UrlEnumValidator {
    constructor([, ...enumValues]) {
        this._enumValues = new Set(enumValues);
    }
    validate(value) {
        return this._enumValues.has(value);
    }
}let DefaultUrlValueValidatorFactory = class DefaultUrlValueValidatorFactory {
    create(args) {
        switch (args[0]) {
            case "range":
                return new UrlRangeValidator(args);
            case "regex":
                return new UrlRegexValidator(args);
            case "enum":
                return new UrlEnumValidator(args);
            default:
                return null;
        }
    }
};
DefaultUrlValueValidatorFactory = __decorate([
    ServiceContract(IUrlValueValidatorFactory)
], DefaultUrlValueValidatorFactory);function createApplicationPartModule(app, builder) {
    return builder
        .configure(x => configureDefaultAppPartServices(app, x))
        .setup(IApplicationPart, x => {
        ApplicationPartLifecycleHooks.invoke(x, ApplicationPartLifecycleHooks.setup);
    }, true)
        .build();
}
function configureDefaultAppPartServices(app, services) {
    services.addInstance(IApplicationPart, app, { scope: ServiceScope.container })
        .addScoped(PartRouteData, { scope: ServiceScope.container })
        .addScopedFactory(ContainerRouteDataRoutingObserverFactory, { scope: ServiceScope.container })
        .addScoped(ContainerRouteData, { scope: ServiceScope.container })
        .addScoped(DefaultNavigationService, { scope: ServiceScope.container })
        .addSingleton(DefaultUrlValueConverterFactory)
        .addSingleton(DefaultUrlValueValidatorFactory)
        .addSingleton(DefaultRouteParser)
        .addSingleton(DefaultRoutingTable, { scope: ServiceScope.container })
        .addScoped(DefaultRouter, { scope: ServiceScope.container })
        .addScoped(DefaultRoutingHandlerInvoker, { scope: ServiceScope.container });
    for (const desc of extractImplicitLifecycleImpl(services)) {
        services.addTransient(ApplicationPartLifecycleWrapper, { baseArgs: [desc], scope: ServiceScope.container });
    }
}
function extractImplicitLifecycleImpl(services) {
    const explicitLifeCycles = new Set();
    const implicitLifeCycles = [];
    for (const desc of services) {
        if (desc.serviceId === IApplicationPartLifecycle) {
            explicitLifeCycles.add(desc.targetType);
        }
        else if (ApplicationPartLifecycleHooks.hasAny(desc.ctor)) {
            implicitLifeCycles.push(desc);
        }
    }
    return implicitLifeCycles.filter(x => !explicitLifeCycles.has(x.targetType));
}class ApplicationPart extends DisposableHost {
    get name() { return this._module.name; }
    get path() { return this._module.path; }
    get running() { return this._module.running; }
    get activeRoute() { return this._current[0]; }
    get activeChild() { return this._current[1]; }
    get ready() { return this._module.ready.then(() => this); }
    get abortToken() { return this._module.abortToken; }
    get services() { return this._module.services; }
    get logger() { return this._module.services.get(ILogger, true); }
    constructor(builder) {
        super();
        this._children = new Map();
        this._current = [];
        this.registerForDispose(this._module = createApplicationPartModule(this, builder));
    }
    getChild(name) {
        return this._children.get(name);
    }
    async addChild(delayedChild) {
        const child = await delayedChild.get();
        const current = this._children.get(child.name);
        IDisposable.safeDispose(current);
        this._children.set(child.name, child);
        if (child instanceof DisposableHost) {
            child.registerForDispose(IDisposable.create(() => this.deleteChild(child.name)));
        }
    }
    deleteChild(name) {
        const current = this._children.get(name);
        if (current) {
            this._children.delete(name);
            if (current === this._current[1]) {
                this._current = [];
            }
        }
    }
    /**
     *
     * @returns
     */
    start() { return this._module.start(); }
    /**
     * Load a new application part as a child of the current part and activate it
     * @param name The name of the part
     * @param route The route that will be used to activate the part
     * @param configHandler The configuration handler used to configure the part
     * @returns The loaded part
     */
    async load(name, route, configHandler) {
        const current = this._children.get(name);
        if (current) {
            await this.activate(name, route);
            return current;
        }
        const builder = this.createAppBuilder(name);
        const handlerCtor = IAppConfigureHandler.resolve(configHandler);
        const handler = this.services.createInstance(handlerCtor);
        handler[configure](builder, this);
        const part = builder.build();
        await part.start();
        await this.activate(name, route);
        return part;
    }
    async activate(name, route) {
        var _a;
        if (!name)
            throw new Error(`"name" parameter cannot be null or empty`);
        if (this._current[0] === route && ((_a = this._current[1]) === null || _a === void 0 ? void 0 : _a.name) === name) {
            this.logger.debug(`Part "{name}" is already activated`, name);
            return;
        }
        const part = this._children.get(name);
        if (part) {
            const current = this._current[1];
            if (current) {
                const allParts = [...Iterables.create(current, x => x.activeChild)].reverse();
                for (const part of allParts) {
                    this.desactivatePart(part);
                }
            }
            await this.activatePart(part);
            this._current = [route, part];
        }
        else {
            this.logger.error(null, `Cannot find any part named "{name}"`, name);
        }
    }
    async desactivate(name) {
        var _a;
        if (((_a = this._current[1]) === null || _a === void 0 ? void 0 : _a.name) === name) {
            await this.desactivatePart(this._current[1]);
        }
    }
    async activatePart(part) {
        this.logger.debug(`Activating part "{name}"`, part.name);
        try {
            await ApplicationPartLifecycleHooks.invoke(part, ApplicationPartLifecycleHooks.activated);
            this.logger.info(`Part "{name}" activated`, part.name);
        }
        catch (err) {
            this.logger.error(err, `Error while activating part "{name}"`, part.name);
            return;
        }
    }
    async desactivatePart(part) {
        this.logger.debug(`Desactivating current active parts from "{path}"`, part.path);
        try {
            await ApplicationPartLifecycleHooks.invoke(part, ApplicationPartLifecycleHooks.deactivated);
            if (part instanceof ApplicationPart) {
                part._current = [];
            }
            this.logger.info(`Part "{path}" desactivated`, part.path);
            return true;
        }
        catch (err) {
            this.logger.error(err, `Error while desactivating part "{path}"`, part.path);
            return false;
        }
    }
    createChildScope(name) {
        this.throwIfExists(name);
        return this._module.createChildScope(name);
    }
    throwIfExists(name) {
        if (this._children.has(name)) {
            throw new Error(`An application part with the same name already exists`);
        }
    }
    dispose() {
        this._current = [];
        IDisposable.safeDispose(this._children.values());
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            yield __await(yield* __asyncDelegator(__asyncValues(this._children.values())));
        });
    }
}
__decorate([
    Memoize
], ApplicationPart.prototype, "ready", null);
__decorate([
    Memoize
], ApplicationPart.prototype, "logger", null);class DefaultApplicationConfigureHandler {
    [configure](builder, host) {
        builder.configure(x => {
            x.addInstance(RoutingOptions, defaultRoutingOptions)
                .addSingleton(DefaultNavigationHandler, { scope: ServiceScope.container, baseArgs: [location] })
                .addSingleton(HistoryNavigationHandler, { scope: ServiceScope.container, baseArgs: [location, window] })
                .addSingleton(HyperlinkNavigationHandler, { scope: ServiceScope.container });
        });
    }
}class ChildApplicationPartBuilder extends ApplicationPartBuilder {
    constructor(partName, source, result) {
        super(partName, source, result);
    }
    createApplicationPart(parent, iocBuilder) {
        return new ChildApplicationPart(parent, iocBuilder);
    }
}
class ChildApplicationPart extends ApplicationPart {
    get parent() { return this._parent; }
    constructor(_parent, builder) {
        super(builder);
        this._parent = _parent;
    }
    createAppBuilder(name) {
        const result = new Delayed();
        this.addChild(result);
        return new ChildApplicationPartBuilder(name, this, result);
    }
}class SinglePageAppBuilder extends ApplicationPartBuilder {
    createApplicationPart(parent, iocBuilder) {
        return new SinglePageApplication(parent, iocBuilder);
    }
}
class SinglePageApplication extends ApplicationPart {
    get parent() { return this._parent; }
    constructor(_parent, builder) {
        super(builder);
        this._parent = _parent;
    }
    createAppBuilder(name) {
        const result = new Delayed();
        this.addChild(result);
        return new ChildApplicationPartBuilder(name, this, result);
    }
    static createKernel() {
        const builder = IoCKernel.create();
        builder.configure(x => {
            x.addConsoleLogger(0 /* LogLevel.trace */);
        });
        return builder.build();
    }
    async start() {
        if (await this._parent.start() && await super.start()) {
            await this.activatePart(this);
            return true;
        }
        return false;
    }
    static create(appName, ...handlerCtors) {
        const kernel = SinglePageApplication.createKernel();
        const result = new Delayed();
        const builder = new SinglePageAppBuilder(appName, kernel, result);
        for (const handlerCtor of handlerCtors) {
            const handler = kernel.services.createInstance(handlerCtor);
            handler[configure](builder);
        }
        return builder;
    }
    static async start(appName, configHandler) {
        const handler = IAppConfigureHandler.resolve(configHandler);
        const app = SinglePageApplication.create(appName, DefaultApplicationConfigureHandler, handler).build();
        await app.start();
        asserts.instanceOf(app, SinglePageApplication);
        return app;
    }
}var HtmlInsertionMode;
(function (HtmlInsertionMode) {
    HtmlInsertionMode[HtmlInsertionMode["replace"] = 0] = "replace";
    HtmlInsertionMode[HtmlInsertionMode["append"] = 1] = "append";
    HtmlInsertionMode[HtmlInsertionMode["prepend"] = 2] = "prepend";
})(HtmlInsertionMode || (HtmlInsertionMode = {}));const IRendererService = ServiceIdentifier("IRendererService");
let DefaultRendererService = class DefaultRendererService {
    render(data) {
        const actual = document.body.querySelector("#default-renderer-output");
        if (actual)
            actual.remove();
        const div = document.createElement("div");
        div.innerText = data;
        div.id = "default-renderer-output";
        document.body.appendChild(div);
    }
};
DefaultRendererService = __decorate([
    ServiceContract(IRendererService)
], DefaultRendererService);SinglePageApplication.start("Library", (builder) => {
    builder.configure(x => x.addSingleton(DefaultRendererService));
    builder.addAction("/:view/*", IRendererService, (renderer, data) => renderer.render(`Selected view: ${data.values["view"]}`));
});//# sourceMappingURL=demo.min.js.map
